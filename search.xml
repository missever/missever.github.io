<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[May Holidays]]></title>
      <url>%2F2018%2F05%2F05%2FCF-477-E%2F</url>
      <content type="text"><![CDATA[题目传送门树链剖分+分块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;vector&lt;int&gt; g[maxn];int sz[maxn], fa[maxn], dep[maxn], son[maxn];int top[maxn], dfn[maxn];int cnt = 0;void dfs1(int u, int father) &#123; dep[u] = dep[father] + 1; fa[u] = father; sz[u] = 1; son[u] = -1; for(auto v : g[u]) &#123; if(v == father) continue; dfs1(v, u); sz[u] += sz[v]; if(son[u] == -1 || sz[v] &gt; sz[son[u]]) son[u] = v; &#125;&#125;void dfs2(int u, int t) &#123; top[u] = t; dfn[u] = ++cnt; if(son[u] == -1) return; dfs2(son[u], t); for(auto v : g[u]) &#123; if(v == son[u] || v == fa[u]) continue; dfs2(v, v); &#125;&#125;int a[maxn], fd[maxn];int fl[405], fr[405], tag[405], ans = 0;bool off[maxn];unsigned char fp[405][maxn &lt;&lt; 1];void add(int k, int l, int r, int v) &#123; for(int i = l;i &lt;= r; i++) &#123; if(off[i]) &#123; a[i] += v; continue; &#125; if(a[i] + tag[k] &lt; maxn) ans--; fp[k][a[i]]--; a[i] += v; if(a[i] + tag[k] &lt; maxn) ans++; fp[k][a[i]]++; &#125;&#125;void add(int x, int v) &#123; off[x] ^= 1; ans += v * (a[x] + tag[fd[x]] &lt; maxn); fp[fd[x]][a[x]] += v;&#125;void update(int l, int r, int v) &#123; if(fd[l] == fd[r]) add(fd[l], l, r, v); else &#123; add(fd[l], l, fr[fd[l]], v); add(fd[r], fl[fd[r]], r, v); for(int i = fd[l] + 1;i &lt; fd[r]; i++) &#123; if(v &lt; 0) ans += fp[i][maxn - tag[i]]; tag[i] += v; if(v &gt; 0) ans -= fp[i][maxn - tag[i]]; &#125; &#125;&#125;void modify(int u, int v, int val) &#123; int x = top[u], y = top[v]; while(x != y) &#123; int &amp;w = dep[x] &gt; dep[y] ? u : v; int &amp;z = dep[x] &gt; dep[y] ? x : y; update(dfn[z], dfn[w], val); w = fa[z]; z = top[w]; &#125; u = dfn[u]; v = dfn[v]; if(u &gt; v) swap(u, v); update(u, v, val);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n, m, i, j, u; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 2; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;u); g[u].push_back(i); &#125; dfs1(1, 0); dfs2(1, 1); for(i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[dfn[i]]); for(i = 1; i &lt;= n; i++) a[i] += maxn; fl[1] = 1; for(i = j = u = 1; i &lt;= n; i++, u++) &#123; if(u == 333) &#123; j++; u = 1; fl[j] = i; &#125; fd[i] = j; fr[j] = i; fp[j][a[i]]++; &#125; for(i = 0;i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;u); if(u &gt; 0) &#123; add(dfn[u], -1); modify(u, 1, -1); &#125; else &#123; add(dfn[-u], 1); modify(-u, 1, 1); &#125; printf(&quot;%d%c&quot;, ans, &quot; \n&quot;[i + 1 == m]); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Perpetual Subtraction]]></title>
      <url>%2F2018%2F04%2F29%2FCF_470_E%2F</url>
      <content type="text"><![CDATA[题目传送门可以很容易的得出dp方程然后得出转移矩阵矩阵快速幂优化dp即可由于这个矩阵很大,我们需要考虑更多优化因为转移矩阵是个上三角矩阵,所以可以进行对角化对角化之后发现特征向量矩阵乘一个向量其实就是一个卷积,可以用$fft$优化然后就神奇的在$nlogn$时间复杂度内做出来了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;const int N = 1 &lt;&lt; 18;const int P = 998244353;const int G = 3;const int NUM = 20;int wn[NUM];int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / P * P;&#125;int add(int x, int y) &#123; x += y; if(x &gt;= P) x -= P; return x;&#125;int powt(int a, LL b) &#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = mul(ans, a); b &gt;&gt;= 1; a = mul(a, a); &#125; return ans;&#125;void GetWn() &#123; for(int i = 0; i &lt; NUM; i++) &#123; int t = 1 &lt;&lt; i; wn[i] = powt(G, (P - 1) / t); &#125;&#125;void NTT(int a[], int len, int t) &#123; for (int i = 0, j = 0; i &lt; len; i++) &#123; if (i &gt; j) swap(a[i], a[j]); for (int l = len &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); &#125; int id = 0; for(int h = 2; h &lt;= len; h &lt;&lt;= 1) &#123; id++; for(int j = 0; j &lt; len; j += h) &#123; int w = 1; for(int k = j; k &lt; j + h / 2; ++k) &#123; int u = a[k]; int t = mul(w, a[k + h / 2]); a[k] = add(u, t); a[k + h / 2] = add(u, P - t); w = mul(w, wn[id]); &#125; &#125; &#125; if(t == -1) &#123; for(int i = 1; i &lt; len / 2; i++) swap(a[i], a[len - i]); LL inv = powt(len, P - 2); for(int i = 0; i &lt; len; i++) a[i] = mul(a[i], inv); &#125;&#125;int a[maxn], p[maxn], inv[maxn];int f[N], g[N];int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif GetWn(); int n, i; LL m; scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); for(i = 0;i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(i = p[0] = 1;i &lt;= n; i++) p[i] = mul(p[i - 1], i); inv[n] = powt(p[n], P - 2); for(i = n - 1;i &gt;= 0; i--) inv[i] = mul(inv[i + 1], i + 1); for(i = 0;i &lt;= n; i++) f[i] = inv[i]; for(i = 0;i &lt;= n; i++) g[n - i] = mul(p[i], a[i]); NTT(f, N, 1); NTT(g, N, 1); for(i = 0;i &lt; N; i++) f[i] = mul(f[i], g[i]); NTT(f, N, -1); for(i = 0;i &lt;= n; i++) a[i] = mul(mul(f[n - i], inv[i]), powt(powt(i + 1, P - 2), m)); memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); for(i = 0;i &lt;= n; i++) f[i] = inv[i]; for(i = 0;i &lt;= n; i++) &#123; g[n - i] = mul(p[i], a[i]); if(i &amp; 1) g[n - i] = add(0, P - g[n - i]); &#125; NTT(f, N, 1); NTT(g, N, 1); for(i = 0;i &lt; N; i++) f[i] = mul(f[i], g[i]); NTT(f, N, -1); for(i = 0;i &lt;= n; i++) &#123; a[i] = mul(f[n - i], inv[i]); if(i &amp; 1) a[i] = add(0, P - a[i]); &#125; for(i = 0;i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Circles of Waiting]]></title>
      <url>%2F2018%2F04%2F29%2FCF_475_E%2F</url>
      <content type="text"><![CDATA[题目传送门很容易列出期望的方程,高斯消元搞一波但是常规消元复杂度是$O(r^6)$的考虑从左到右从上到下编号然后按编号从小到大消元假设黄点是已经消元的点,那么消下一个点的时候,只有绿点的方程中该项系数不为0同时,该点的方程中也只有绿点的那些项的系数不为0由于绿点的个数是$O(r)$的,那么每次消元的复杂度就是$O(r^2)$的总体消元复杂度就是$O(r^4)$的然后现在得到了上三角矩阵由于只需要求$(0,0)$点的值所以只需要把那一行的其它元消掉这个的复杂度也是$O(r^4)$的总体复杂度是$O(r^4)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 8005;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int powt(int a, int b) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r = mul(r, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return r;&#125;int f[maxn][maxn];int id[111][111], a[4], dx[4] = &#123; -1, 0, 1, 0&#125;, dy[4] = &#123;0, -1, 0, 1&#125;;vector&lt;int&gt; c;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n = 0, r, i, j, k, x, y, u, v; scanf(&quot;%d&quot;, &amp;r); for(i = j = 0; i &lt; 4; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); j += a[i]; &#125; j = powt(j, mod - 2); for(i = 0; i &lt; 4; i++) a[i] = mod - mul(a[i], j); for(i = -r; i &lt;= r; i++) &#123; for(j = -r; j &lt;= r; j++) &#123; if(i * i + j * j &lt;= r * r) id[i + 55][j + 55] = ++n; &#125; &#125; for(i = -r; i &lt;= r; i++) &#123; for(j = -r; j &lt;= r; j++) &#123; if(u = id[i + 55][j + 55]) &#123; f[u][0] = f[u][u] = 1; for(k = 0; k &lt; 4; k++) &#123; x = i + dx[k]; y = j + dy[k]; if(v = id[x + 55][y + 55]) f[u][v] = a[k]; &#125; &#125; &#125; &#125; for(i = 1;i &lt;= n; i++) &#123; u = min(n, i + r * 2 + 1); c.clear(); c.push_back(0); for(j = i;j &lt;= u; j++) &#123; if(f[i][j]) c.push_back(j); &#125; for(j = i + 1;j &lt;= u; j++) &#123; if(f[j][i]) &#123; v = mul(mod - f[j][i], powt(f[i][i], mod - 2)); for(auto e:c) f[j][e] = add(f[j][e], mul(f[i][e], v)); &#125; &#125; &#125; u = id[55][55]; for(i = 1;i &lt;= n; i++) &#123; if(i == u) continue; if(f[u][i]) &#123; v = mul(mod - f[u][i], powt(f[i][i], mod - 2)); for(j = 0;j &lt;= n; j++) f[u][j] = add(f[u][j], mul(f[i][j], v)); &#125; &#125; v = powt(f[u][u], mod - 2); printf(&quot;%d\n&quot;, mul(f[u][0], v)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Visible Black Areas]]></title>
      <url>%2F2018%2F04%2F23%2FCF_edu42_G%2F</url>
      <content type="text"><![CDATA[题目传送门求出边与方框的交点，并记录边的朝向，得到出点和入点方框内的图形在方框上的点一定是入点出点交错先并查集合并相邻出点-入点，再合并入点-出点 即可注意边界情况和各种特殊情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;struct Point &#123; int x, y; Point(int _x = 0, int _y = 0): x(_x), y(_y) &#123;&#125; Point operator + (const Point &amp;b) const &#123; return Point(x + b.x, y + b.y); &#125; Point operator - (const Point &amp;b) const &#123; return Point(x - b.x, y - b.y); &#125; int operator ^ (const Point &amp;b) const &#123; return (x * b.y - y * b.x); &#125;&#125; p[maxn];Point a, b, c, d, e;int w, h;vector&lt;P&gt; f;bool isPointOnSegment(Point p, Point s, Point e) &#123; return ((p - s) ^ (s - e)) == 0 &amp;&amp; ((p.x - s.x) * (p.x - e.x)) &lt;= 0 &amp;&amp; ((p.y - s.y) * (p.y - e.y)) &lt;= 0;&#125;void pre_solve(Point u, Point v) &#123; if(u.x == v.x) &#123; if(u.x == a.x || u.x == b.x) return; if(min(u.y, v.y) &gt;= c.y || max(u.y, v.y) &lt;= a.y) return; if(abs(u.y - a.y) &lt; abs(u.y - d.y)) &#123; e = Point(u.x, a.y); if(isPointOnSegment(e, a, b) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(e.x - a.x, ((b - a) ^ (v - a)) &gt; 0)); e = Point(u.x, c.y); if(isPointOnSegment(e, c, d) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(w + h + c.x - e.x, ((d - c) ^ (v - c)) &gt; 0)); &#125; else &#123; e = Point(u.x, c.y); if(isPointOnSegment(e, c, d) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(w + h + c.x - e.x, ((d - c) ^ (v - c)) &gt; 0)); e = Point(u.x, a.y); if(isPointOnSegment(e, a, b) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(e.x - a.x, ((b - a) ^ (v - a)) &gt; 0)); &#125; &#125; else &#123; if(u.y == a.y || u.y == d.y) return; if(min(u.x, v.x) &gt;= c.x || max(u.x, v.x) &lt;= a.x) return; if(abs(u.x - a.x) &lt; abs(u.x - b.x)) &#123; e = Point(a.x, u.y); if(isPointOnSegment(e, a, d) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(w + w + h + d.y - e.y, ((a - d) ^ (v - d)) &gt; 0)); e = Point(c.x, u.y); if(isPointOnSegment(e, b, c) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(w + e.y - b.y, ((c - b) ^ (v - b)) &gt; 0)); &#125; else &#123; e = Point(c.x, u.y); if(isPointOnSegment(e, b, c) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(w + e.y - b.y, ((c - b) ^ (v - b)) &gt; 0)); e = Point(a.x, u.y); if(isPointOnSegment(e, a, d) &amp;&amp; isPointOnSegment(e, u, v)) f.push_back(P(w + w + h + d.y - e.y, ((a - d) ^ (v - d)) &gt; 0)); &#125; &#125;&#125;int inConvexPoly(int n, Point a) &#123; p[n] = p[0]; for(int i = 0; i &lt; n; i++) &#123; if(((p[i] - a) ^ (p[i + 1] - a)) &lt; 0) return 0; else if(isPointOnSegment(a, p[i], p[i + 1])) return 1; &#125; return 1;&#125;int check(int n) &#123; int vis = 1; for(int i = 0; i &lt; n; i++) &#123; if(a.x &lt;= p[i].x &amp;&amp; p[i].x &lt;= c.x &amp;&amp; a.y &lt;= p[i].y &amp;&amp; p[i].y &lt;= c.y) vis &amp;= 1; else vis = 0; &#125; if(!vis) &#123; vis = 1; vis &amp;= inConvexPoly(n, a); vis &amp;= inConvexPoly(n, b); vis &amp;= inConvexPoly(n, c); vis &amp;= inConvexPoly(n, d); &#125; return vis;&#125;int fp[maxn], tot;int ff(int x) &#123; if(fp[x] != x) fp[x] = ff(fp[x]); return fp[x];&#125;void funion(int x, int y) &#123; x = ff(x); y = ff(y); if(x != y) &#123; fp[x] = y; tot--; &#125;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n, m, i; scanf(&quot;%d%d%d%d&quot;, &amp;a.x, &amp;c.y, &amp;c.x, &amp;a.y); b = Point(c.x, a. y); d = Point(a.x, c. y); w = c.x - a.x; h = c.y - a.y; scanf(&quot;%d&quot;, &amp;n); for(i = 0; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y); p[n] = p[0]; for(i = 0; i &lt; n; i++) pre_solve(p[i], p[i + 1]); tot = m = f.size(); if(m == 0) &#123; printf(&quot;%d\n&quot;, check(n)); return 0; &#125; for(i = 0; i &lt;= (w + h) * 2; i++) fp[i] = i; for(i = 1; i &lt; m; i++) &#123; if(f[i - 1].se == 1 &amp;&amp; f[i].se == 0) funion(f[i - 1].fi, f[i].fi); &#125; if(f[m - 1].se == 1 &amp;&amp; f[0].se == 0) funion(f[m - 1].fi, f[0].fi); sort(f.begin(), f.end()); f.push_back(f[0]); for(i = 0; i &lt; m; i++) &#123; if(f[i].se == 0 &amp;&amp; f[i + 1].se == 1) funion(f[i].fi, f[i + 1].fi); &#125; printf(&quot;%d\n&quot;, tot); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018川大校赛补]]></title>
      <url>%2F2018%2F04%2F23%2F2018scu%2F</url>
      <content type="text"><![CDATA[SCU-4581由于内存限制,对$v &lt; 1e6$做普通背包,对$n &lt; 20$做容斥即可想到了容斥居然想不出组合数公式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int BUFFER_MAX_SIZE = 100000;struct Quick_In &#123; char buf[BUFFER_MAX_SIZE], *ps = buf, *pe = buf + 1; inline void InNext() &#123; if (++ps == pe) pe = (ps = buf) + fread(buf, sizeof(char), sizeof(buf) / sizeof(char), stdin); &#125; template&lt;class T&gt; inline bool operator()(T &amp;number) &#123; number = 0; T f = 1; bool vis_point = 0; if (ps == pe) return false; //EOF do &#123; InNext(); if (&apos;-&apos; == *ps) f = -1; &#125; while (ps != pe &amp;&amp; !isdigit(*ps)); if (ps == pe) return false; //EOF do &#123; if((*ps) == &apos;.&apos;) vis_point = 1; else &#123; number = number * 10 + *ps - 48; if(vis_point) f *= 0.1; &#125; InNext(); &#125; while (ps != pe &amp;&amp; (isdigit(*ps) || (*ps) == &apos;.&apos;)); number *= f; return true; &#125;&#125; In;const int maxn = 2e5 + 5;const int mod = 1e9 + 7;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int powt(int x, int y) &#123; int r = 1; while(y) &#123; if(y &amp; 1) r = mul(r, x); x = mul(x, x); y &gt;&gt;= 1; &#125; return r;&#125;int f[maxn], a[20];int C(int n, int m) &#123; if(m &gt; n) return 0; int res = 1; for(int i = 0;i &lt; m; i++) res = mul(res, mul(n - i, powt(i + 1, mod - 2))); return res;&#125;void solve() &#123; int n, v, w, c, i, j, res; In(n); In(v); if(v &lt; maxn) &#123; for(i = 0; i &lt;= v; i++) f[v] = 0; f[0] = 1; for(i = 0; i &lt; n; i++) &#123; In(c); for(j = v - c + 1, res = 0; j &lt;= v; j++) res = add(res, f[j]); for(j = v; j &gt; 0; j--) &#123; res = add(res, mod - f[j]); if(j &gt;= c) res = add(res, f[j - c]); f[j] = add(f[j], res); &#125; &#125; printf(&quot;%d\n&quot;, f[v]); &#125; else &#123; for(i = 0;i &lt; n; i++) In(a[i]); for(i = res = 0;i &lt; (1 &lt;&lt; n); i++) &#123; for(j = c = 0, w = v;j &lt; n; j++) &#123; if((i &gt;&gt; j) &amp; 1) &#123; w -= a[j] + 1; c++; &#125; &#125; if(c &amp; 1) res = add(res, mod - C(w + n - 1, n - 1)); else res = add(res, C(w + n - 1, n - 1)); &#125; printf(&quot;%d\n&quot;, res); &#125;&#125;int main() &#123;#ifdef CX_TEST //freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t; scanf(&quot;%d&quot;, &amp;t); while(t--) solve(); return 0;&#125; SCU-4589题意:求质数的$k$次方前缀和一种类似欧拉筛法的基本应用吧复杂度是$O(k * n^{3/4}/logn)$的这个手写$k$次方自然数前缀和真恶心123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 5;int mod, k;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;LL mul(LL a, LL b, LL m) &#123; LL r = (a * b - (LL)(((long double)a * b) / m) * m); r = r - r / m * m; if(r &lt; 0) r += m; return r;&#125;int powt(int x, int y) &#123; int r = 1; while(y) &#123; if(y &amp; 1) r = mul(r, x); x = mul(x, x); y &gt;&gt;= 1; &#125; return r;&#125;int fg[maxn], pri[maxn];LL sum[maxn];int cnt = 0;void GetPrime() &#123; for (int i = 2; i &lt; maxn; ++i) &#123; if (!fg[i]) pri[cnt++] = i; for (int j = 0; j &lt; cnt &amp;&amp; pri[j] * i &lt; maxn; ++j) &#123; fg[pri[j] * i] = 1; if (i % pri[j] == 0) break; &#125; &#125;&#125;int S(int n) &#123; int res; if(k == 0) res = n % mod; else if(k == 1) res = 1LL * n * (n + 1) / 2 % mod; else if(k == 2) &#123; LL m = 1LL * mod * 6; res = mul(mul(n, n + 1, m), 2 * n + 1, m) / 6; &#125; else if(k == 3) &#123; LL m = 1LL * mod * 4; res = mul(mul(n, n + 1, m), mul(n, n + 1, m), m) / 4; &#125; else if(k == 4) &#123; LL m = 1LL * mod * 30; LL d = mul(6LL * n + 9, n, m); d = mul(d + 1, n, m) + m - 1; res = mul(d, mul(n, n + 1, m), m) / 30; &#125; else if(k == 5) &#123; LL m = 1LL * mod * 12; LL d = mul(2LL * n + 4, n, m); d = mul(d + 1, n, m) + m - 1; res = mul(d, mul(mul(n, n, m), n + 1, m), m) / 12; &#125; else if(k == 6) &#123; LL m = 1LL * mod * 42; LL d = mul(6LL * n + 15, n, m); d = mul(d + 6, n, m); d = mul(d + m - 6, n, m); d = mul(d + m - 1, n, m) + 1; res = mul(d, mul(n, n + 1, m), m) / 42; &#125; else if(k == 7) &#123; LL m = 1LL * mod * 24; LL d = mul(3LL * n + 9, n, m); d = mul(d + 5, n, m); d = mul(d + m - 5, n, m); d = mul(d + m - 2, n, m) + 2; res = mul(d, mul(mul(n, n, m), n + 1, m), m) / 24; &#125; else if(k == 8) &#123; LL m = 1LL * mod * 90; LL d = mul(10LL * n + 35, n, m); d = mul(d + 25, n, m); d = mul(d + m - 25, n, m); d = mul(d + m - 17, n, m); d = mul(d + 17, n, m); d = mul(d + 3, n, m) + m - 3; res = mul(d, mul(n, n + 1, m), m) / 90; &#125; else if(k == 9) &#123; LL m = 1LL * mod * 20; LL d = mul(2LL * n + 8, n, m); d = mul(d + 7, n, m); d = mul(d + m - 7, n, m); d = mul(d + m - 7, n, m); d = mul(d + 7, n, m); d = mul(d + 3, n, m) + m - 3; res = mul(d, mul(mul(n, n, m), n + 1, m), m) / 20; &#125; else &#123; LL m = 1LL * mod * 66; LL d = mul(6LL * n + 27, n, m); d = mul(d + 28, n, m); d = mul(d + m - 28, n, m); d = mul(d + m - 38, n, m); d = mul(d + 38, n, m); d = mul(d + 28, n, m); d = mul(d + m - 28, n, m); d = mul(d + m - 5, n, m) + 5; res = mul(d, mul(n, n + 1, m), m) / 66; &#125; return add(res, mod - 1);&#125;LL fa[maxn], fb[maxn];void solve() &#123; LL i, r, n; scanf(&quot;%lld%d%d&quot;, &amp;n, &amp;k, &amp;mod); for(r = 1; 1LL * r * r &lt;= n; r++) fa[r] = S(r); for(i = 1; i &lt; r; i++) fb[i] = S(n / i); for(LL p = 2; p &lt; r; p++) &#123; if(!fg[p]) &#123; int pw = powt(p, k); for(i = 1; i &lt;= min(r - 1, n / p / p); i++) &#123; if(p * i &lt; r) fb[i] = add(fb[i], mod - mul(pw, add(fb[i * p], mod - fa[p - 1]))); else fb[i] = add(fb[i], mod - mul(pw, add(fa[n / p / i], mod - fa[p - 1]))); &#125; for(i = r - 1; i &gt;= p * p; i--) fa[i] = add(fa[i], mod - mul(pw, add(fa[i / p], mod - fa[p - 1]))); &#125; &#125; printf(&quot;%lld\n&quot;, fb[1]);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t; GetPrime(); scanf(&quot;%d&quot;, &amp;t); while(t--) solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CDOJ 1825 柱爷搞搞搞搞搞xxxxoooorrrrr]]></title>
      <url>%2F2018%2F02%2F27%2FCDOJ%201825%2F</url>
      <content type="text"><![CDATA[题面传送门类似数位DP的思想,考虑对于这$n$个数的前$i$位,我们对每个数的前$i$位选的都是它的上界(最大值),那么这前$i$位的异或和结果只有一种,然后我们考虑它们的第$i + 1$位存在一些数选的不是上界,假设第一个没有选上界的数为第$j$个,那么存在其它数随便选后,第$j$个数最后总能选择一个数使得最后的异或和为给定值.(因为第$j$个数能选择的数的范围是一个全集)我们可以$O(n)$的DP出前$i$位都选上界,第$i + 1$位存在一些数选的不是上界的情况下产生的方案数.按位枚举,总复杂度就是$nlog_{2}1e9$整体思想类似DP套DP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 5;const int mod = 1e9 + 7;void add(int &amp;x, int y) &#123; x += y; if(x &gt;= mod) x -= mod;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int f[maxn][2][2], a[maxn];int solve(int n, int k, int e) &#123; int i, j, res = (1 &lt;&lt; k) - 1; memset(f, 0, sizeof(f)); f[0][0][0] = 1; for(i = 0; i &lt; n; i++) &#123; j = (a[i] &amp; res) + 1; if((a[i] &gt;&gt; k) &amp; 1) &#123; add(f[i + 1][0][1], f[i][0][0]); add(f[i + 1][1][1], f[i][1][0]); add(f[i + 1][0][1], mul(f[i][0][1], 1 &lt;&lt; k)); add(f[i + 1][1][1], mul(f[i][1][1], 1 &lt;&lt; k)); add(f[i + 1][1][0], mul(f[i][0][0], j)); add(f[i + 1][0][0], mul(f[i][1][0], j)); add(f[i + 1][1][1], mul(f[i][0][1], j)); add(f[i + 1][0][1], mul(f[i][1][1], j)); &#125; else &#123; f[i + 1][0][0] = mul(f[i][0][0], j); f[i + 1][0][1] = mul(f[i][0][1], j); f[i + 1][1][0] = mul(f[i][1][0], j); f[i + 1][1][1] = mul(f[i][1][1], j); &#125; &#125; return f[n][e][1];&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n, i, k, sum = 0, ans = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum ^= a[i]; &#125; for(i = 30; i &gt;= 0; i--) &#123; add(ans, solve(n, i, (k &gt;&gt; i) &amp; 1)); if((sum &gt;&gt; i) != (k &gt;&gt; i)) break; &#125; if(sum == k) add(ans, 1); printf(&quot;%d\n&quot;, ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hdu5848 Easy Homework]]></title>
      <url>%2F2018%2F01%2F23%2Fhdu5848%2F</url>
      <content type="text"><![CDATA[题面传送门感觉非常恶心的数学题…………首先我们需要先发现这个等式$f_{n}^{2}-f_{n-1}f_{n+1}=(-1)^{n}$证明的话把通项公式代入,再联系该数列的特征方程并利用韦达定理就行了对$n$分奇偶性讨论,然后令$f_{n} = x,f_{n - 1} = y$的话就是一个关于$y$的一元二次方程了利用二次剩余解出$y$,没有二次剩余就无解有了$x,y$就相当于有了终状态$B$构造转移矩阵$A$求$A^{k}=B\%p$的解,可以用BSGS实现另一个难点可能是BSGS的范围……我们知道这个数列在模$p$意义下是有循环节的,对于这道题,循环节规模在$O(p)$量级,可以利用通用的矩阵的循环节公式求得最小循环节……这个循环节大小就是BSGS的范围有点卡常数……需要手写hash表才行……或许是我写得太挫了update:那个转移矩阵可以只用两个元素表示……似乎可减少一半的常数？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 5;int mod, wf;default_random_engine generator(time(NULL));uniform_int_distribution&lt;LL&gt; df(1, 1e18);int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int powt(int a, int b) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r = mul(r, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return r;&#125;template&lt;typename T, typename U&gt;struct HashMap &#123; static const int M = 333331; int chk[M], cn; int q[M], qn; vector&lt;T&gt; a; vector&lt;U&gt; b; int fst[M], m; vector&lt;int&gt; nxt; HashMap() &#123; memset(fst, -1, sizeof fst); cn++; &#125; void clear() &#123; for (int i = 0; i &lt; qn; i++) fst[q[i]] = -1; cn++; qn = m = 0; a.clear(), b.clear(), nxt.clear(); &#125; U&amp; operator[](T x) &#123; int r = (x % M + M) % M; for (int e = fst[r]; ~e; e = nxt[e]) &#123; if (a[e] == x) &#123; return b[e]; &#125; &#125; if (chk[r] != cn) &#123; chk[r] = cn; q[qn++] = r; &#125; a.push_back(x), b.push_back(U()); nxt.push_back(fst[r]), fst[r] = m++; return b.back(); &#125; bool count(T x) &#123; int r = (x % M + M) % M; for (int e = fst[r]; ~e; e = nxt[e]) &#123; if (a[e] == x) &#123; return 1; &#125; &#125; return 0; &#125;&#125;;const int msize = 2;struct matrix &#123; int a[msize][msize]; void clear() &#123; memset(a, 0, sizeof(a)); &#125; matrix operator *(const matrix &amp;b) const &#123; matrix tmp; tmp.clear(); for(int i = 0; i &lt; msize; i++) &#123; for(int j = 0; j &lt; msize; j++) &#123; for(int k = 0; k &lt; msize; k++) &#123; tmp.a[i][j] = add(tmp.a[i][j], mul(a[i][k], b.a[k][j])); &#125; &#125; &#125; return tmp; &#125; bool operator ==(const matrix &amp;b) const &#123; for(int i = 0; i &lt; msize; i++) &#123; for(int j = 0; j &lt; msize; j++) &#123; if(a[i][j] != b.a[i][j]) return false; &#125; &#125; return true; &#125;&#125;;matrix powt(matrix a, LL b) &#123; matrix r = &#123;1, 0, 0, 1&#125;; while(b) &#123; if(b &amp; 1) r = r * a; a = a * a; b &gt;&gt;= 1; &#125; return r;&#125;struct node &#123; int p, d; node operator * (const node &amp;b) const &#123; node r; r.p = add(mul(p, b.p), mul(mul(d, b.d), wf)); r.d = add(mul(p, b.d), mul(d, b.p)); return r; &#125;&#125;;node powt(node a, int b) &#123; node r = node&#123;1, 0&#125;; while(b) &#123; if(b &amp; 1) r = r * a; a = a * a; b &gt;&gt;= 1; &#125; return r;&#125;int Legendre(int a) &#123; return powt(a, (mod - 1) &gt;&gt; 1);&#125;int get_ans(int x) &#123; if(x == 0) return 0; if(powt(x, (mod - 1) &gt;&gt; 1) + 1 == mod) return -1; int a; while(true) &#123; a = df(generator) % mod; wf = add(mul(a, a), mod - x); if(Legendre(wf) + 1 == mod) break; &#125; node tmp = node&#123;a, 1&#125;; return powt(tmp, (mod + 1) &gt;&gt; 1).p;&#125;int pri[maxn], cnt = 0;void GetPrime() &#123; for (int i = 2; i &lt; maxn; ++i) &#123; if (!pri[i]) pri[cnt++] = i; for (int j = 0; j &lt; cnt &amp;&amp; pri[j] * i &lt; maxn; ++j) &#123; pri[pri[j] * i] = 1; if (i % pri[j] == 0) break; &#125; &#125;&#125;vector&lt;int&gt; fac;void get_fac(int x) &#123; for(int i = 0; pri[i] * pri[i] &lt;= x; i++) &#123; while(x % pri[i] == 0) &#123; fac.push_back(pri[i]); x /= pri[i]; &#125; &#125; if(x &gt; 1) fac.push_back(x);&#125;LL get_cycle(int a) &#123; matrix r = &#123;a, 1, 1, 0&#125;; matrix u = &#123;1, 0, 0, 1&#125;; fac.clear(); get_fac(mod - 1); //get_fac(mod - 1); get_fac(mod + 1); fac.push_back(mod); int n = fac.size(); LL d = 1; for(int i = 0; i &lt; n; i++) &#123; matrix v = r; for(int j = i + 1; j &lt; n; j++) v = powt(v, fac[j]); if(u == v) continue; d *= fac[i]; r = powt(r, fac[i]); &#125; return d;&#125;HashMap &lt;LL, int&gt; q;LL solve(int fa, int a, int b, LL len, LL l, LL r, int k) &#123; int i, j, m = ceil(sqrt(1.0 * len)); LL x, dl, dr, ans = 0; matrix v = &#123;fa, 1, 1, 0&#125;; matrix u = &#123;add(mul(fa, b), a), b, b, a&#125;; q.clear(); for(i = 0; i &lt; m; i++) &#123; q[1LL * u.a[0][0] * mod + u.a[1][0]] = i; u = u * v; &#125; u = v = powt(v, m); for(i = 1; i &lt;= m; i++) &#123; if(q.count(1LL * u.a[0][0] * mod + u.a[1][0])) &#123; j = q[1LL * u.a[0][0] * mod + u.a[1][0]]; x = 1LL * i * m - j; if(x &lt;= len) &#123; dl = (l - 1) / len; dr = r / len; if((l - 1) % len &gt;= x) dl++; if(r % len &gt;= x) dr++; if(len &amp; 1) &#123; if(((x + dl * len) &amp; 1) == k) ans += (dr - dl + 1) / 2; else ans += (dr - dl) / 2; &#125; else &#123; if((x &amp; 1) == k) ans += dr - dl; &#125; &#125; break; &#125; u = u * v; &#125; return ans;&#125;void solve() &#123; int a, x, u, d, y1, y2, inv; LL l, r, ans = 0; scanf(&quot;%d%d%d%lld%lld&quot;, &amp;a, &amp;mod, &amp;x, &amp;l, &amp;r); LL len = get_cycle(a); inv = (mod + 1) &gt;&gt; 1; d = mul(a, x); d = add(mul(d, d), mul(4, mul(x, x))); u = get_ans(add(d, mul(4, mod - 1))); if(u &gt; 0) &#123; y1 = mul(add(u, mod - mul(a, x)), inv); y2 = mul(mod - add(u, mul(a, x)), inv); ans += solve(a, y1, x, len, l, r, 1); ans += solve(a, y2, x, len, l, r, 1); &#125; u = get_ans(add(d, 4)); if(u &gt; 0) &#123; y1 = mul(add(u, mod - mul(a, x)), inv); y2 = mul(mod - add(u, mul(a, x)), inv); ans += solve(a, y1, x, len, l, r, 0); ans += solve(a, y2, x, len, l, r, 0); &#125; printf(&quot;%lld\n&quot;, ans);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t; GetPrime(); scanf(&quot;%d&quot;, &amp;t); while(t--) solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Power Substring]]></title>
      <url>%2F2018%2F01%2F17%2FCF_Hello2018_G%2F</url>
      <content type="text"><![CDATA[题目传送门考虑求$a * 10 ^ {m} + x \equiv 2 ^ {k} \% 10 ^ {n + m}$,$n$是$a$在十进制下的位数然后考虑中国剩余定理,先求一个满足$a*10^{m}+x \equiv 2^{k} \% 2^{n+m}$的解令$k &gt; n + m,y = (a*10^{m}+x) \% 2^{n + m} + i * 2^{n + m}$,因为对于$2^{k} \% 5^{n+m}$来说,$2$是模数的一个原根,只要保证$y \% 5 != 0$就可以保证存在$k$满足所有等式然后转为求$(y / 2^{n + m}) \equiv 2 ^{k} \% 5 ^ {n + m}$的$k$的值然后有个公式可以优化:若$a ^ {k} \equiv c \% p^{i}$则存在$0 \leq j \leq p - 1$满足$a ^ {k + j * \varphi(p^{i})} \equiv c \% p^{i+1}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 5;LL mod;LL add(LL x, LL y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;LL mul(LL a, LL b) &#123; LL r = (a * b - (LL)(((long double)a * b) / mod) * mod); return add(r - r / mod * mod, mod);&#125;LL powt(LL a,LL b) &#123; LL r = 1; while(b &gt;= 1) &#123; if(b &amp; 1) r = mul(r,a); a = mul(a,a); b &gt;&gt;= 1; &#125; return r;&#125;int f[] = &#123; -1, 0, 1, 3, 2&#125;;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t, n, m, i; LL a, b, x, k, phi; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%lld&quot;, &amp;a); n = to_string(a).size(); for(m = 0, b = 1; 1; m++, a *= 10, b *= 10) &#123; x = a; mod = 1LL &lt;&lt; (n + m); if(x % mod) x += mod - x % mod; if(x % 5 == 0) x += mod; if(x % mod == 0 &amp;&amp; x % 5 &amp;&amp; x - a &lt; b) &#123; x &gt;&gt;= n + m; k = f[x % 5]; for(i = 1,phi = 4,mod = 25; i &lt; n + m; i++,mod *= 5,phi *= 5) &#123; while(powt(2,k) != x % mod) k += phi; &#125; printf(&quot;%lld\n&quot;,n + m + k); break; &#125; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_GoodBye2017简单题解]]></title>
      <url>%2F2018%2F01%2F17%2FCF_goodbye2017%2F</url>
      <content type="text"><![CDATA[题目传送门 A.New Year and Counting Cards签到题12345678910111213141516171819char s[maxn];int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif scanf(&quot;%s&quot;,s); int n = strlen(s); int t = 0; for(int i = 0;i &lt; n; i++) &#123; if(s[i] &gt;= &apos;a&apos; &amp;&amp; s[i] &lt;= &apos;z&apos;) &#123; if(s[i] == &apos;a&apos; || s[i] == &apos;e&apos; || s[i] == &apos;i&apos; || s[i] == &apos;o&apos; || s[i] == &apos;u&apos;) t++; &#125; else &#123; if(s[i] == &apos;1&apos; || s[i] == &apos;3&apos; || s[i] == &apos;5&apos; || s[i] == &apos;7&apos; || s[i] == &apos;9&apos;) t++; &#125; &#125; printf(&quot;%d\n&quot;,t); return 0;&#125; B.New Year and Buggy Bot签到题……手残打错一个小于号1234567891011121314151617181920212223242526272829303132333435363738394041char p[55][55];char s[maxn];int n,m,f[4],d[maxn];bool check(int w) &#123; int i,j,k; for(i = 0;i &lt; n; i++) &#123; for(j = 0;j &lt; m; j++) &#123; if(p[i][j] == &apos;S&apos;) break; &#125; if(j &lt; m) break; &#125; for(k = 0;k &lt; w; k++) &#123; if(d[k] == 0) i++; else if(d[k] == 1) i--; else if(d[k] == 2) j++; else j--; if(i &lt; 0 || i == n || j &lt; 0 || j == m) return false; if(p[i][j] == &apos;#&apos;) return false; if(p[i][j] == &apos;E&apos;) return true; &#125; return false;&#125;int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int w,i,ans = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i = 0;i &lt; n; i++) scanf(&quot;%s&quot;,p[i]); scanf(&quot;%s&quot;,s); w = strlen(s); for(i = 0;i &lt; 4; i++) f[i] = i; do &#123; for(i = 0;i &lt; w; i++) d[i] = f[s[i] - &apos;0&apos;]; if(check(w)) ans++; &#125; while(next_permutation(f,f + 4)); printf(&quot;%d\n&quot;,ans); return 0;&#125; C.New Year and Curling水题123456789101112131415161718192021222324double fy[1005];int dx[1005];int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,r,i,j; double y,yy; scanf(&quot;%d%d&quot;,&amp;n,&amp;r); for(i = 0;i &lt; n; i++) &#123; scanf(&quot;%d&quot;,&amp;dx[i]); y = r; for(j = 0;j &lt; i; j++) &#123; if(abs(dx[i] - dx[j]) &lt;= 2 * r) &#123; yy = sqrt(4.0 * r * r - 1.0 * (dx[i] - dx[j]) * (dx[i] - dx[j])); y = max(y,fy[j] + yy); &#125; &#125; fy[i] = y; &#125; for(i = 0;i &lt; n; i++) printf(&quot;%.10f &quot;,fy[i]); return 0;&#125; D.New Year and Arbitrary Arrangement$f[i][j]$表示有$i$个$a$字符并且当前已经有$j$个$ab$序列的概率当$i+j &gt;= k$的时候,再加一个$b$字符就肯定结束,可以直接推出加一个$b$字符产生的期望贡献所以$dp$总复杂度也就$k^{2}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int add(int x,int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x,int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int powt(int a,int b) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r= mul(r,a); a = mul(a,a); b &gt;&gt;= 1; &#125; return r;&#125;int f[2005][2005];int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int i,j,k,pa,pb,p,inv,w,ans = 0; scanf(&quot;%d%d%d&quot;,&amp;k,&amp;pa,&amp;pb); p = pa + pb; inv = powt(p,mod - 2); w = add(mul(p,powt(pb,mod - 2)),mod - 1); f[1][0] = 1; for(i = 1;i &lt;= 2000; i++) &#123; for(j = 0;j &lt;= 2000; j++) &#123; if(f[i][j]) &#123; if(i + j &gt;= k) ans = add(ans,mul(f[i][j],add(i + j,w))); else &#123; f[i + 1][j] = add(f[i + 1][j],mul(f[i][j],mul(pa,inv))); f[i][i + j] = add(f[i][i + j],mul(f[i][j],mul(pb,inv))); &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125; E.New Year and Entity Enumeration把状态相同的列放到一组,每组的答案就是非空集合的划分方案数,即贝尔数最后乘起来就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int powt(int a, int b) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r = mul(r, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return r;&#125;char s[1005];char f[1005][55];int g[1005];int c[1005],b[1005];int C(int x,int y) &#123; return mul(c[x],powt(mul(c[y],c[x - y]),mod - 2));&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int m, n, i, j; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); c[0] = 1; for(i = 1;i &lt;= m; i++) c[i] = mul(c[i - 1],i); b[0] = 1; for(i = 1;i &lt;= m; i++) &#123; for(j = 0;j &lt; i; j++) b[i] = add(b[i],mul(b[j],C(i - 1,j))); &#125; for(i = 0; i &lt; n; i++) &#123; scanf(&quot; %s&quot;, s); for(j = 0; j &lt; m; j++) f[j][i] = s[j]; &#125; for(i = 0; i &lt; m; i++) f[i][n] = 0; for(i = 0; i &lt; m; i++) &#123; for(j = 0; j &lt; i; j++) &#123; if(strcmp(f[i], f[j]) == 0) break; &#125; g[j]++; &#125; int ans = 1; for(i = 0;i &lt; m; i++) &#123; ans = mul(ans,b[g[i]]); &#125; printf(&quot;%d\n&quot;, ans); return 0;&#125; F.New Year and Rainbow Roads考虑每两个$G$相互独立,它们之间要么通过$B,R$相连,要么直接相连,两种情况讨论一下就行了12345678910111213141516171819202122232425262728293031323334int n, x, z, lr, lg, lb, mr, mb;char c;int main() &#123;#ifdef CX_TEST //freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d %c&quot;, &amp;x, &amp;c); if (c == &apos;R&apos; || c == &apos;G&apos;) &#123; if (lr &gt; 0) &#123; z += x - lr; mr = max(mr, x - lr); &#125; lr = x; &#125; if (c == &apos;B&apos; || c == &apos;G&apos;) &#123; if (lb &gt; 0) &#123; z += x - lb; mb = max(mb, x - lb); &#125; lb = x; &#125; if (c == &apos;G&apos;) &#123; if (lg &gt; 0 &amp;&amp; mr + mb &gt; x - lg) &#123; z += x - lg - mr - mb; &#125; lg = x; mr = mb = 0; &#125; &#125; printf(&quot;%d\n&quot;, z); return 0;&#125; G.New Year and Original Order考虑求出比$k$小的数字的个数有$j$个的数字的个数为$f[j][k]$把数字$k$的贡献拆成$k$个$1$那么$f[j][k]$对答案的贡献就是$f[j][k] * g[n - j],g[i]$是$i$个$1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 705;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;void update(int &amp;a, int b) &#123; a += b; if(a &gt;= mod) a -= mod;&#125;char s[maxn];int a[maxn],p[maxn],g[maxn];int f[maxn][maxn][10][2];int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n, i, j, k, l, ans = 0; scanf(&quot; %s&quot;, s); n = strlen(s); for(i = p[0] = 1; i &lt; maxn; i++) p[i] = mul(p[i - 1], 10); for(i = 1; i &lt; maxn; i++) g[i] = add(g[i - 1], p[i - 1]); for(i = 0; i &lt; n; i++) a[i] = s[i] - &apos;0&apos;; for(i = 1; i &lt; 10; i++) f[0][0][i][0] = 1; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; for(k = 1; k &lt; 10; k++) &#123; if(f[i][j][k][0]) &#123; for(l = 0; l &lt; a[i]; l++) update(f[i + 1][j + (l &lt; k)][k][1], f[i][j][k][0]); update(f[i + 1][j + (a[i] &lt; k)][k][0], f[i][j][k][0]); &#125; if(f[i][j][k][1]) &#123; for(l = 0; l &lt; 10; l++) update(f[i + 1][j + (l &lt; k)][k][1], f[i][j][k][1]); &#125; &#125; &#125; &#125; for(i = 0;i &lt; n; i++) &#123; for(k = 1;k &lt; 10; k++) ans = add(ans,mul(g[n - i],add(f[n][i][k][0],f[n][i][k][1]))); &#125; printf(&quot;%d\n&quot;, ans); return 0;&#125; H.New Year and Boolean Bridges先连$A$,并查集维护,对于一个联通块,我们肯定要把它连成一个环如果一个联通块中存在两点的关系为$X$,肯定无解否则考虑把这些联通块合并一下,两个联通块之间的所有点对的关系都是$O$的话可以合并转化成$n/2$个点的图求最小的完全子图划分可以$fwt$维护但是由于我们只需要关注一个值的情况所以可以省去逆变换不如……直接上容斥吧……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 1 &lt;&lt; 23;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x, int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;char s[55][55];int p[55], r[55], d[55], h[55], ans = 0;int f[maxn],g[maxn],bit[maxn];int ff(int x) &#123; if(p[x] != x) p[x] = ff(p[x]); return p[x];&#125;void funion(int x, int y) &#123; x = ff(x); y = ff(y); if(x != y) p[y] = x;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n, m, i, j; scanf(&quot;%d&quot;, &amp;n); for(i = 0; i &lt; n; i++) scanf(&quot; %s&quot;, s[i]); for(i = 0; i &lt; n; i++) p[i] = i; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; if(i == j) continue; if(s[i][j] == &apos;A&apos;) funion(i, j); &#125; &#125; for(i = 0; i &lt; n; i++) d[ff(i)]++; memset(h, -1, sizeof(h)); for(i = m = 0; i &lt; n; i++) &#123; if(d[i] &gt; 1) h[i] = m++; &#125; for(i = 0; i &lt; n; i++) &#123; for(j = 0; j &lt; n; j++) &#123; if(i == j) continue; if(s[i][j] == &apos;X&apos;) &#123; if(ff(i) == ff(j)) &#123; return puts(&quot;-1&quot;), 0; &#125; if(d[ff(i)] &gt; 1 &amp;&amp; d[ff(j)] &gt; 1) &#123; r[h[ff(i)]] |= 1 &lt;&lt; h[ff(j)]; r[h[ff(j)]] |= 1 &lt;&lt; h[ff(i)]; &#125; &#125; &#125; &#125; if(!m) &#123; printf(&quot;%d\n&quot;,n - 1); return 0; &#125; for(i = 0;i &lt; m; i++) r[i] ^= (1 &lt;&lt; m) - 1; for(i = 0; i &lt; (1 &lt;&lt; m); i++) &#123; if((i &amp; (-i)) == i) f[i] = 1; else &#123; j = i ^ (1 &lt;&lt; (__builtin_ffs(i) - 1)); if(f[j] &amp;&amp; (r[i] &amp; j) == j) f[i] = 1; &#125; g[i] = 1; bit[i] = ((m - __builtin_popcount(i)) &amp; 1) ? mod - 1 : 1; &#125; for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; (1 &lt;&lt; m); j++) &#123; if ((j &gt;&gt; i) &amp; 1) f[j] += f[j ^ (1 &lt;&lt; i)]; &#125; &#125; for(i = 0;i &lt; m; i++) &#123; for(j = 0;j &lt; (1 &lt;&lt; m); j++) g[j] = mul(g[j],f[j]); int x = 0; for(j = 0;j &lt; (1 &lt;&lt; m); j++) x = add(x,mul(bit[j],g[j])); if(x) break; &#125; printf(&quot;%d\n&quot;, n + i); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_Educational_Round_34_G]]></title>
      <url>%2F2017%2F12%2F13%2FCF_edu34_G%2F</url>
      <content type="text"><![CDATA[Yet Another Maxflow Problem题目传送门对于点$A_{i}$,它的流量有两种,一种是通过横边流向$B$,一种是流向$A_{i + 1}$.如果以$A_{i}$为分界点,那么答案就是$A$中$\leq i$的点通过横边流出的流量加上流向$A_{i + 1}$的流量.对于每个$A_{i}$,我们假设它流向$A_{i + 1}$是满流,然后通过线段树维护出$A$中$\leq i$的点通过横边实际流出的最大流量,令这两部分和为$c_{i}$.因为$A_{i}$实际流向$A_{i + 1}$的流量是$A_{i}-&gt;A_{i+1}$的边权和$A$中$&gt; i$的点通过横边流出的流量中的最小值,所以答案就是$min(c_{i})$然后每次修改边权的时候只需要用线段树维护单点修改即可.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 2e5 + 5;int ca[maxn];LL f[maxn * 4], ly[maxn * 4], cb[maxn], cc[maxn];struct edge &#123; int u, v, w;&#125; g[maxn];bool cmp(const edge &amp;a, const edge &amp;b) &#123; return a.u &lt; b.u;&#125;void push_down(int t) &#123; if(ly[t]) &#123; f[t &lt;&lt; 1] += ly[t]; ly[t &lt;&lt; 1] += ly[t]; f[t &lt;&lt; 1 | 1] += ly[t]; ly[t &lt;&lt; 1 | 1] += ly[t]; ly[t] = 0; &#125;&#125;void build(int t, int l, int r, LL val[]) &#123; ly[t] = 0; if(l == r) &#123; f[t] = val[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(t &lt;&lt; 1, l, mid, val); build(t &lt;&lt; 1 | 1, mid + 1, r, val); f[t] = min(f[t &lt;&lt; 1], f[t &lt;&lt; 1 | 1]);&#125;void update(int t, int l, int r, int ll, int rr, LL v) &#123; if(ll &lt;= l &amp;&amp; r &lt;= rr) &#123; f[t] += v; ly[t] += v; return; &#125; int mid = (l + r) &gt;&gt; 1; push_down(t); if(ll &lt;= mid) update(t &lt;&lt; 1, l, mid, ll, rr, v); if(rr &gt; mid) update(t &lt;&lt; 1 | 1, mid + 1, r, ll, rr, v); f[t] = min(f[t &lt;&lt; 1], f[t &lt;&lt; 1 | 1]);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n, m, q, i, j; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(i = 1; i &lt; n; i++) scanf(&quot;%d%lld&quot;, &amp;ca[i], &amp;cb[i + 1]); build(1, 1, n, cb); for(i = 0; i &lt; m; i++) scanf(&quot;%d%d%d&quot;, &amp;g[i].u, &amp;g[i].v, &amp;g[i].w); sort(g, g + m, cmp); for(i = 1, j = 0; i &lt;= n; i++) &#123; while(j &lt; m &amp;&amp; g[j].u == i) &#123; update(1, 1, n, 1, g[j].v, g[j].w); j++; &#125; cc[i] = f[1] + ca[i]; &#125; build(1, 1, n, cc); printf(&quot;%lld\n&quot;, f[1]); while(q--) &#123; scanf(&quot;%d%d&quot;, &amp;i, &amp;j); update(1, 1, n, i, i, j - ca[i]); ca[i] = j; printf(&quot;%lld\n&quot;, f[1]); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017CCPC_final补]]></title>
      <url>%2F2017%2F12%2F12%2F2017ccpc-final%2F</url>
      <content type="text"><![CDATA[划水划水划水……然后就挂了…… D.Mr. Panda and Circles分三种情况讨论:两端都没有圆在线段外一端有圆在线段外两端都有圆在线段外……然后就是各种前缀和优化组合数求方案了第三种情况要用到任意模数的fft,然后还要写个前缀和减去自身卷积自身的情况……因为组合数太大了,所以还需要考虑单独维护模数的幂……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int add(int x, int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int fmod(LL x) &#123; return x - x / mod * mod;&#125;int mul(int x, int y) &#123; return fmod(1LL * x * y);&#125;int powt(int a, int b) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r = mul(r, a); a = mul(a, a); b &gt;&gt;= 1; &#125; return r;&#125;int sqr(int x) &#123; return fmod(1LL * x * x);&#125;const int LN = 18;const int N = 1 &lt;&lt; LN;const double pi = acos(-1.0);int fa[N], fb[N];struct Complex &#123; double r, i; Complex(double r = 0.0, double i = 0.0): r(r), i(i) &#123;&#125;; Complex operator + (const Complex &amp;rhs) &#123; return Complex(r + rhs.r, i + rhs.i); &#125; Complex operator - (const Complex &amp;rhs) &#123; return Complex(r - rhs.r, i - rhs.i); &#125; Complex operator * (const Complex &amp;rhs) &#123; return Complex(r * rhs.r - i * rhs.i, i * rhs.r + r * rhs.i); &#125; Complex conj() &#123; return Complex(r, -i); &#125;&#125; wn[N];int bitrev[N];void fft_prepare() &#123; for(int i = 0; i &lt; N; i++) bitrev[i] = bitrev[i &gt;&gt; 1] &gt;&gt; 1 | ((i &amp; 1) &lt;&lt; (LN - 1)); for(int i = 0; i &lt; N; i++) wn[i] = Complex(cos(2 * pi * i / N), sin(2 * pi * i / N));&#125;void FFT(Complex a[], int l, int op) &#123; int d = 0; while((1 &lt;&lt; d) * l != N) d++; for(int i = 0; i &lt; l; i++) &#123; if(i &lt; (bitrev[i] &gt;&gt; d)) swap(a[i], a[(bitrev[i] &gt;&gt; d)]); &#125; for (int i = 2; i &lt;= l; i &lt;&lt;= 1) &#123; int lyc = N / i; for (int j = 0; j &lt; l; j += i) &#123; Complex *l = a + j, *r = a + j + (i &gt;&gt; 1), *p = wn; for(int k = 0; k &lt; (i &gt;&gt; 1); k++) &#123; Complex tmp = *r * *p; *r = *l - tmp, *l = *l + tmp; ++l, ++r, p += lyc; &#125; &#125; &#125; if(op == -1) &#123; for(int i = 0; i &lt; l; i++) &#123; a[i].r /= l; a[i].i /= l; &#125; &#125;&#125;Complex va[N], vb[N], da[N], db[N], dd[N];void Conv(int fa[], int fc[], int l) &#123; int i; for(i = 0; i &lt; l; i++) va[i] = Complex(fa[i] &amp; 32767, fa[i] &gt;&gt; 15); FFT(va, l, 1); for(i = 0; i &lt; l; i++) &#123; int j = (l - i) &amp; (l - 1); Complex qa, qb, qc, qd; qa = (va[i] + va[j].conj()) * Complex(0.5, 0.0); qb = (va[i] - va[j].conj()) * Complex(0.0, -0.5); da[j] = qa * qa; db[j] = qa * qb; dd[j] = qb * qb; &#125; for(i = 0; i &lt; l; i++) va[i] = da[i] + db[i] * Complex(0.0, 1.0); for(i = 0; i &lt; l; i++) vb[i] = db[i] + dd[i] * Complex(0.0, 1.0); FFT(va, l, -1); FFT(vb, l, -1); for(i = 0; i &lt; l; i++) &#123; int wa = fmod(va[i].r + 0.5); int wb = fmod(va[i].i + 0.5); int wc = fmod(vb[i].r + 0.5); int wd = fmod(vb[i].i + 0.5); fc[i] = add(wa, add(fmod(((LL)add(wb, wc)) &lt;&lt; 15), fmod(((LL)wd) &lt;&lt; 30))); &#125;&#125;struct node &#123; int res, cnt; void init(LL a, LL b) &#123; res = 1; cnt = 0; while(a &lt;= b) &#123; int c = fmod(a); if(c == 0) cnt++; else res = mul(res, c); a++; &#125; &#125; int val() &#123; return cnt ? 0 : res; &#125; void add(LL x) &#123; x = fmod(x); if(x == 0) cnt++; else res = mul(res, x); &#125; void del(LL x) &#123; x = fmod(x); if(x == 0) cnt--; else res = mul(res, powt(x, mod - 2)); &#125;&#125; fac;int a[maxn], r[maxn];int solve() &#123; int n, i, x, y, l, rmax = 0, ans = 0; P u; LL m, d, s = 0; scanf(&quot;%d%lld&quot;, &amp;n, &amp;m); for(i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); s += a[i]; rmax = max(rmax, a[i]); &#125; s *= 2; d = m - 1 - s; // step1 if(d &gt; 0) &#123; fac.init(d + 1, d + n); ans = add(ans, mul(sqr(fmod(d)), fac.val())); &#125; // step2 memset(r, 0, sizeof(r)); for(i = 0; i &lt; n; i++) r[a[i]]++; for(i = 100000; i &gt; 0; i--) r[i] += r[i + 1]; i = min(max(0LL, -d), 200000LL); fac.init(d + i + 1, d + i + n - 1); for(i = i + 1, y = 0; i &lt;= 100000; i++) &#123; fac.add(d + i + n - 1); fac.del(d + i); if(r[i]) y = add(y, mul(r[i], mul(fac.val(), sqr(fmod(d + i))))); &#125; ans = add(ans, mul(y, 2)); // step3 if(n == 1) return ans; for(l = 1; l &lt;= (rmax &lt;&lt; 1); l &lt;&lt;= 1); memcpy(fa, r, sizeof(r)); if(l &gt; maxn) fill(fa + maxn,fa + l,0); Conv(fa, fb, l); memset(fa, 0, sizeof(fa)); for(i = 0; i &lt; n; i++) &#123; fa[2]++; fa[a[i] + 2] -= 2; fa[(a[i] &lt;&lt; 1) + 2]++; &#125; for(x = y = i = 0; i &lt; l; i++) &#123; x = add(x, mod + fa[i]); y = add(x, y); fb[i] = add(fb[i], mod - y); &#125; i = min(max(0LL, -d), 500000LL); fac.init(d + i + 1, d + i + n - 2); for(i = i + 1; i &lt; l; i++) &#123; fac.add(d + i + n - 2); fac.del(d + i); if(fb[i]) ans = add(ans, mul(fb[i], mul(fac.val(), sqr(fmod(d + i))))); &#125; return ans;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t, i; fft_prepare(); scanf(&quot;%d&quot;, &amp;t); for(i = 1; i &lt;= t; i++) printf(&quot;Case #%d: %d\n&quot;, i, solve()); return 0;&#125; F.Fair Lottery把等式转化成不等式,直接线性规划莽……不过这个单纯形的板子过不了uoj179的$hack$数据…………似乎没有太大影响?123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int maxn = 1050;const double eps = 1e-8;struct Simplex &#123; int n, m; int idx[maxn], idy[maxn]; double a[maxn][maxn], ans[maxn]; void init(int _n, int _m) &#123; n = _n; m = _m; for(int i = 0; i &lt;= n; i++) idx[i] = i; for(int i = 1; i &lt;= m; i++) idy[i] = i + n; &#125; void pivot(int u, int v) &#123; swap(idx[v], idy[u]); double t = a[u][v]; a[u][v] = 1.0; for(int i = 0; i &lt;= n; i++) a[u][i] /= t; for(int i = 0; i &lt;= m; i++) &#123; if(i == u || fabs(a[i][v]) &lt; eps) continue; t = a[i][v]; a[i][v] = 0; for(int j = 0; j &lt;= n; j++) a[i][j] -= a[u][j] * t; &#125; &#125; bool init_check() &#123; while(true) &#123; int u = 0, v = 0; double mn = -eps; for(int i = 1; i &lt;= m; i++) &#123; if(a[i][0] &lt; mn &amp;&amp; (!u || (rand() &amp; 1))) &#123; mn = a[i][0]; u = i; &#125; &#125; if(!u) return true; mn = -eps; for(int i = 1; i &lt;= n; i++) &#123; if(a[u][i] &lt; mn &amp;&amp; (!v || (rand() &amp; 1))) &#123; mn = a[u][i]; v = i; &#125; &#125; if(!v) return false; pivot(u, v); &#125; &#125; bool do_simplex() &#123; while(true) &#123; int u = 0, v = 0; double mn = 1e15, mx = eps; for(int i = 1; i &lt;= n; i++) &#123; if(a[0][i] &gt; mx &amp;&amp; (!v || (rand() &amp; 1))) &#123; mx = a[0][i]; v = i; &#125; &#125; if(!v) return true; for(int i = 1; i &lt;= m; i++) &#123; if(a[i][v] &gt; eps &amp;&amp; a[i][0] / a[i][v] &lt; mn) &#123; mn = a[i][0] / a[i][v]; u = i; &#125; &#125; if(!u) return false; pivot(u, v); &#125; &#125; void get_ans() &#123; memset(ans, 0, sizeof(ans)); ans[0] = -a[0][0]; for(int i = 1; i &lt;= m; i++) &#123; if(idy[i] &lt;= n) ans[idy[i]] = a[i][0]; &#125; &#125;&#125; sf;int d[15], f[12][1050];double solve() &#123; int n, m, i, j, x, tot = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;d[i]); memset(f, 0, sizeof(f)); for(i = 0; i &lt; (1 &lt;&lt; n); i++) &#123; for(j = x = 0; j &lt; n; j++) &#123; if((i &gt;&gt; j) &amp; 1) x += d[j]; &#125; if(x &lt;= m) &#123; tot++; for(j = 0; j &lt; n; j++) &#123; if((i &gt;&gt; j) &amp; 1) f[j][tot] = 1; &#125; &#125; &#125; sf.init(tot, n + 2); for(i = 0;i &lt;= tot; i++) sf.a[0][i] = f[0][i]; for(i = 1;i &lt; n; i++) &#123; for(j = 0;j &lt;= tot; j++) sf.a[i][j] = f[i][j] - f[i - 1][j]; &#125; for(j = 0;j &lt;= tot; j++) sf.a[n][j] = f[0][j] - f[n - 1][j]; for(j = 1;j &lt;= tot; j++) &#123; sf.a[n + 1][j] = 1; sf.a[n + 2][j] = -1; &#125; sf.a[n + 1][0] = 1; sf.a[n + 2][0] = -1; sf.init_check(); sf.do_simplex(); return -sf.a[0][0];&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif srand(time(NULL)); int t, i; scanf(&quot;%d&quot;, &amp;t); for(i = 1; i &lt;= t; i++) printf(&quot;Case #%d: %.10f\n&quot;, i, solve()); return 0;&#125; H.Equidistance先求出$m-1$个线性无关的基向量,然后随机一个向量尝试把这组基向量扩展到满秩即可…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const double eps = 1e-8;inline sgn(double x) &#123; if(x &lt; -eps) return -1; else if(x &gt; eps) return 1; else return 0;&#125;int n, m;struct Point &#123; vector&lt;double&gt; a; Point operator +(const Point &amp;b) const &#123; Point c; c.a.resize(n); for(int i = 0; i &lt; n; i++) c.a[i] = a[i] + b.a[i]; return c; &#125; Point operator -(const Point &amp;b) const &#123; Point c; c.a.resize(n); for(int i = 0; i &lt; n; i++) c.a[i] = a[i] - b.a[i]; return c; &#125; double operator *(const Point &amp;b) const &#123; double res = 0; for(int i = 0; i &lt; n; i++) res += a[i] * b.a[i]; return res; &#125; Point operator *(const double &amp;b) const &#123; Point c = *this; for(int i = 0; i &lt; n; i++) c.a[i] *= b; return c; &#125;&#125; p[105], f[105], s, us;uniform_real_distribution&lt;double&gt; df(-100, 100);default_random_engine gen(time(NULL));Point work() &#123; Point x; x.a.resize(n); while(true) &#123; for(int i = 0; i &lt; n; i++) x.a[i] = df(gen); for(int i = 1; i &lt; m; i++) &#123; double u = x * f[i]; x = x - f[i] * u; &#125; if((x * x) &gt; eps) return x; &#125;&#125;void solve() &#123; int i, j; double u; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); printf(&quot;%d\n&quot;, n + 1 - m); s.a.clear(); s.a.resize(n,0); for(i = 0; i &lt; m; i++) &#123; p[i].a.resize(n); for(j = 0; j &lt; n; j++) scanf(&quot;%lf&quot;, &amp;p[i].a[j]); s = s + p[i]; &#125; us = s * (1.0 / m); for(i = 1; i &lt; m; i++) &#123; f[i] = p[i] - us; for(j = 1; j &lt; i; j++) &#123; u = f[i] * f[j]; f[i] = f[i] - f[j] * u; &#125; u = sqrt(f[i] * f[i]); f[i] = f[i] * (1.0 / u); &#125; while(m &lt; n + 1) &#123; p[m] = work(); u = sqrt(p[m] * p[m]); double v = sqrt(1.0 - (p[0] - us) * (p[0] - us)); p[m] = p[m] * (v / u) + us; for(i = 0; i &lt; n; i++) printf(&quot;%.10f%c&quot;, p[m].a[i], &quot; \n&quot;[i + 1 == n]); f[m] = p[m] - us; u = sqrt(f[m] * f[m]); f[m] = f[m] * (1.0 / u); s = s + p[m]; us = s * (1.0 / (++m)); &#125;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int i, t; scanf(&quot;%d&quot;, &amp;t); for(i = 1; i &lt;= t; i++) &#123; printf(&quot;Case #%d: &quot;, i); solve(); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#449(Div. 1)简单题解]]></title>
      <url>%2F2017%2F12%2F08%2FCF-449%2F</url>
      <content type="text"><![CDATA[题目传送门 A.Nephren gives a riddle水题……12345678910111213141516171819202122232425262728293031323334353637383940414243444546//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;char s0[] = &quot;What are you doing at the end of the world? Are you busy? Will you save us?&quot;;char s1[] = &quot;What are you doing while sending \&quot;&quot;;char s2[] = &quot;\&quot;? Are you busy? Will you send \&quot;&quot;;char s3[] = &quot;\&quot;?&quot;;LL f[maxn],mm = 1e18 + 1e5;char solve(int n,LL k) &#123; if(f[n] &lt; k) return &apos;.&apos;; if(n == 0) return s0[k - 1]; if(k &lt;= strlen(s1)) return s1[k - 1]; k -= strlen(s1); if(k &lt;= f[n - 1]) return solve(n - 1,k); k -= f[n - 1]; if(k &lt;= strlen(s2)) return s2[k - 1]; k -= strlen(s2); if(k &lt;= f[n - 1]) return solve(n - 1,k); k -= f[n - 1]; return s3[k - 1];&#125;int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int i,q,n; LL k; f[0] = strlen(s0); for(i = 1;i &lt; maxn; i++) f[i] = min(mm,(LL)strlen(s1) + (LL)strlen(s2) + (LL)strlen(s3) + f[i - 1] * 2); scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); printf(&quot;%c&quot;,solve(n,k)); &#125; return 0;&#125; B.Ithea Plays With Chtholly从左到右和从右到左分别维护一个单调队列……那么入队次数最多也就最多$\frac{nc}{2}$次,就像一个直角三角形的两个锐角向直角延伸的样子……1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;vector&lt;int&gt; l,r;int n;void solvel(int x) &#123; if(l.empty() || l.back() &lt;= x) &#123; l.push_back(x); printf(&quot;%d\n&quot;,(int)l.size()); &#125; else &#123; int d = upper_bound(l.begin(),l.end(),x) - l.begin(); l[d] = x; printf(&quot;%d\n&quot;,d + 1); &#125;&#125;void solver(int x) &#123; if(r.empty() || r.back() &gt;= x) &#123; r.push_back(x); printf(&quot;%d\n&quot;,n - (int)r.size() + 1); &#125; else &#123; int d; for(d = 0;d &lt; r.size(); d++) if(r[d] &lt; x) break; r[d] = x; printf(&quot;%d\n&quot;,n - d); &#125;&#125;int main()&#123;#ifdef CX_TEST //freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int m,c,i,x; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c); while(1) &#123; scanf(&quot;%d&quot;,&amp;x); if(x * 2 &lt;= c) solvel(x); else solver(x); fflush(stdout); if(l.size() + r.size() == n) break; &#125; return 0;&#125; C.Willem, Chtholly and Seniorious因为操作纯随机,所以2操作不会太少,而得到的区间的期望长度是$\frac{n}{3}$,所以操作一定次数后只有较少的值不同的区间,所以暴力维护就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;LL,int&gt; PL;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int add(int x,int y,int m) &#123; x += y; if(x &gt;= m) x -= m; return x;&#125;int mul(int x,int y,int m) &#123; LL z = 1LL * x * y; return z - z / m * m;&#125;int powt(int a,int b,int m) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r = mul(r,a,m); a = mul(a,a,m); b &gt;&gt;= 1; &#125; return r;&#125;LL a[maxn];int seed,vmax;set&lt;P&gt; q;vector&lt;P&gt; f;vector&lt;PL&gt; g;int rnd() &#123; int u = seed; seed = add(mul(seed,7,mod),13,mod); return u;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,m,i,j,op,x,y,l,r; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;seed,&amp;vmax); for(i = 1; i &lt;= n; i++) a[i] = rnd() % vmax + 1; for(i = j = 1; i &lt;= n; i = j) &#123; while(a[j] ==a[i]) j++; q.insert(P(j - 1,i)); &#125; for(i = 1; i &lt;= m; i++) &#123; op = (rnd() &amp; 3) + 1; l = rnd() % n + 1; r = rnd() % n + 1; if(l &gt; r) swap(l,r); auto e = q.lower_bound(P(l,0)); if(op == 3) &#123; x = rnd() % (r - l + 1) + 1; g.clear(); if(r &lt;= (*e).first) &#123; printf(&quot;%lld\n&quot;,a[(*e).first]); continue; &#125; while(e != q.end() &amp;&amp; (*e).second &lt;= r) &#123; g.push_back(PL(a[(*e).first],min((*e).first,r) - max((*e).second,l) + 1)); e++; &#125; sort(g.begin(),g.end()); for(auto w:g) &#123; x -= w.second; if(x &lt;= 0) &#123; printf(&quot;%lld\n&quot;,w.first); break; &#125; &#125; &#125; else &#123; x = rnd() % vmax + 1; j = 0; if(op == 4) &#123; y = rnd() % vmax + 1; while(e != q.end() &amp;&amp; (*e).second &lt;= r) &#123; //cout&lt;&lt;a[(*e).first]&lt;&lt;&quot; &quot;&lt;&lt;min((*e).first,r) - max((*e).second,l) + 1&lt;&lt;endl; j = add(j,mul(powt(a[(*e).first] % y,x,y),min((*e).first,r) - max((*e).second,l) + 1,y),y); e++; &#125; printf(&quot;%d\n&quot;,j); &#125; else &#123; f.clear(); while(e != q.end() &amp;&amp; (*e).second &lt;= r) &#123; f.push_back(*e); e++; &#125; if(op == 1) &#123; for(auto u:f) &#123; q.erase(u); if(u.first &gt; r) q.insert(P(u.first,r + 1)); if(u.second &lt; l) &#123; q.insert(P(l - 1,u.second)); a[l - 1] = a[u.first]; &#125; q.insert(P(min(u.first,r),max(u.second,l))); a[min(u.first,r)] = a[u.first] + x; &#125; &#125; else &#123; for(auto u:f) &#123; q.erase(u); if(u.first &gt; r) q.insert(P(u.first,r + 1)); if(u.second &lt; l) &#123; q.insert(P(l - 1,u.second)); a[l - 1] = a[u.first]; &#125; &#125; q.insert(P(r,l)); a[r] = x; &#125; &#125; &#125; &#125; return 0;&#125; D.Nephren Runs a Cinema固定VIP的人数,剩下的等价于括号匹配方案数,考虑卡特兰数和组合数的那个关系式就好了？似乎以前都没注意过那个式子呀因为模数不是质数,所以仿照扩展卢卡斯一样,用CRT合并就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL,LL&gt; P;typedef pair&lt;LL,LL&gt; PL;const LL mod = 1e9 + 7;const LL maxn = 1e5 + 5;LL add(LL x,LL y,LL m) &#123; x += y; if(x &gt;= m) x -= m; return x;&#125;LL mul(LL x,LL y,LL m) &#123; LL z = 1LL * x * y; return z - z / m * m;&#125;LL powt(LL a,LL b,LL m) &#123; LL r = 1; while(b) &#123; if(b &amp; 1) r = mul(r,a,m); a = mul(a,a,m); b &gt;&gt;= 1; &#125; return r;&#125;void extend_Euclid(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0) &#123; x = 1; y = 0; return; &#125; extend_Euclid(b, a % b, x, y); LL tmp = x; x = y; y = tmp - (a / b) * y;&#125;LL Inv(LL a,LL b) &#123; LL x,y; extend_Euclid(a,b,x,y); return (x % b + b) % b;&#125;LL CRT(vector&lt;LL&gt; &amp;a,vector&lt;LL&gt; &amp;m,LL M) &#123; LL ans = 0,n = a.size(); for(LL i = 0; i &lt; n; i++) &#123; LL x,y; LL Mi = M / m[i]; extend_Euclid(Mi, m[i], x, y); x = (x % M + M) % M; ans = add(ans,mul(mul(Mi,x,M),a[i],M),M); &#125; return ans;&#125;map&lt;LL,LL&gt; fac;vector&lt;LL&gt; fa,fm;struct node &#123; LL u,t,p; LL f[maxn],g[maxn]; void init(LL a,LL b) &#123; LL i,x; u = a; t = b; p = powt(a,b,mod * 2); for(i = f[0] = 1;i &lt;= 100000; i++) &#123; for(x = i;x % u == 0; x /= u); f[i] = mul(f[i - 1],x,p); &#125; memset(g,0,sizeof(g)); for(i = 1;i * u &lt;= 100000; i++) g[i * u] = g[i] + 1; for(i = 1;i &lt;= 100000; i++) g[i] += g[i - 1]; &#125; LL get_mul(LL n,LL m) &#123; if(m &lt; 0 || n &lt; m) return 0; LL tc = g[n] - g[m] - g[n - m]; if(tc &gt;= t) return 0; return mul(powt(u,tc,mod * 2),mul(f[n],Inv(mul(f[m],f[n - m],p),p),p),p); &#125;&#125; fs[20];LL tot = 0;void init(LL n) &#123; for(LL i = 2; i * i &lt;= n; i++) &#123; while(n % i == 0) &#123; fac[i]++; n /= i; &#125; &#125; if(n &gt; 1) fac[n]++; for(auto e:fac) &#123; fs[tot].init(e.first,e.second); fm.push_back(fs[tot++].p); &#125;&#125;LL cal(LL n,LL m,LL p) &#123; fa.clear(); for(LL i = 0;i &lt; tot; i++) fa.push_back(fs[i].get_mul(n,m)); return CRT(fa,fm,p);&#125;LL solve(LL n,LL k,LL l,LL r,LL p) &#123; if(k + l &gt; n) return 0; LL ans = cal(n,k,p); n -= k; r = min(r,n); if((n - r) &amp; 1) r--; if((n - l) &amp; 1) l++; r += 2; LL d = cal(n,(n - l) &gt;&gt; 1,p); if(r &lt;= n) d = add(d,p - cal(n,(n - r) &gt;&gt; 1,p),p); return mul(ans,d,p);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,p,l,r,ans = 0; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;p,&amp;l,&amp;r); init(p); for(LL i = 0;i &lt;= n; i++) ans = add(ans,solve(n,i,l,r,p),p); printf(&quot;%d\n&quot;,ans); return 0;&#125; E.Welcome home, Chtholly直接暴力一波即可过分块,对于整个块的1操作,维护块内的最大最小值$v_{max},v_{min}$,如果$v_{min} + x + x \leq v_{max}$,把小于$x$的数加上$x$然后整个块减$x$即可,否则就把大于$x$的数暴力维护减去$x$的数加上$x$然后整个块减$x$即可因为这样做是一直在缩小区间,并且每个值只会访问一次,所以可以保证对于一个块的总操作次数是$O(n)$的为了实现这样的操作,需要用并查集维护每个数被修改后变成了哪个值,因为每次并查集修改后指向的值都是上述操作未被访问过的值,所以不会存在重叠或循环的问题…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;const int bsize = 340;struct block &#123; int d[maxn], p[maxn], l, r; void add(int x) &#123; d[x]++; r = max(x, r); &#125; int ff(int x) &#123; if(p[x] == 0) p[x] = x; if(p[x] != x) p[x] = ff(p[x]); return p[x]; &#125; void update(int x) &#123; if(x + l &gt; r) return; if(l + x + x &lt;= r) &#123; for(int i = l + 1; i &lt;= l + x; i++) &#123; if(d[i]) &#123; d[i + x] += d[i]; d[i] = 0; p[i] = i + x; &#125; &#125; l += x; &#125; else &#123; for(int i = l + x + 1; i &lt;= r; i++) &#123; if(d[i]) &#123; d[i - x] += d[i]; d[i] = 0; p[i] = i - x; &#125; &#125; r = l + x; &#125; &#125; int query(int x) &#123; if(x + l &gt; r) return 0; else return d[x + l]; &#125;&#125; f[bsize];int a[maxn], id[maxn], n;void rebuild(int k, int l, int r, int x) &#123; for(int i = l; i &lt;= r; i++) &#123; a[i] = f[k].ff(a[i]); if(a[i] &gt; x + f[k].l) &#123; f[k].d[a[i]]--; a[i] -= x; f[k].d[a[i]]++; &#125; &#125;&#125;int query(int k, int l, int r, int x) &#123; int t = 0; for(int i = l; i &lt;= r; i++) &#123; if(f[k].ff(a[i]) == x + f[k].l) t++; &#125; return t;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int m, i, j, k, op, l, r, x; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 1, j = k = 0; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); id[i] = k; f[k].add(a[i]); if(++j == bsize) &#123; j = 0; k++; &#125; &#125; while(m--) &#123; scanf(&quot;%d%d%d%d&quot;, &amp;op, &amp;l, &amp;r, &amp;x); if(op == 1) &#123; if(id[l] == id[r]) rebuild(id[l], l, r, x); else &#123; rebuild(id[l], l, (id[l] + 1) * bsize, x); rebuild(id[r], id[r] * bsize + 1, r, x); for(i = id[l] + 1; i &lt; id[r]; i++) f[i].update(x); &#125; &#125; else &#123; if(id[l] == id[r]) k = query(id[l], l, r, x); else &#123; k = query(id[l], l, (id[l] + 1) * bsize, x); k += query(id[r], id[r] * bsize + 1, r, x); for(i = id[l] + 1; i &lt; id[r]; i++) k += f[i].query(x); &#125; printf(&quot;%d\n&quot;, k); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[假如我们能够从头再来]]></title>
      <url>%2F2017%2F12%2F04%2F20171204%2F</url>
      <content type="text"><![CDATA[哈尔滨的寒风……就这么吹进了心里…… 听着熟悉的歌，想到了熟悉的人，一种孤独感突然就那么蔓延了开来想要忆起一些过往，却发现自己似乎没有什么太深刻的过往呢……大学生涯变得越来越单调了，失去的东西好像也越来越多了。之前还能绷紧神经过着充实的训练和补题，现在突然就感觉那是多么的累，亦有一种无可奈何的凄凉感，无论再怎么做，总会有一些东西不会，永远的做不完……永远的学不全……而且，每次盯着屏幕上那昂贵的票价时的望洋兴叹，每次为了寻找一个便宜了几十块钱的辗转多次的线路时的纠结，都让我感觉好烦好累… 当初我选择acm的原因是什么呢?似乎已经记不得了，好像也没有什么特别的原因吧，可能是带着高中的一些遗憾，可能是众多竞赛中只有它我比较熟悉吧（虽然也是在大学才知道的acm）……不管是因为什么，选了就会努力做好它……似乎自己确实做得不太好，总会掉一下链子。每当感觉自己现在这个样子还不错的时候，总是会遇到一些神奇的题，把我打回原形，然后又不停的补题，学习一些新套路……但是，学了这么多，即使会做很多人难题，却总是感觉缺了些什么，似乎只会运用，当自己想构思一个好思路时，却总是想不出什么东西，给自己一种半吊子的感觉。 组队的时候也感觉自己发不出力来……明明感觉自己的能力是可以carry的，却时不时变成划水选手，虽然这里面还有其它的因素，但是总不该是这样的…… 以上或许都是无病呻吟吧……反正明天还是会和往常一样，打开熟悉的网页，做着千奇百怪的题……今年又要结束了呀……题目是什么，随便取一个吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[无名]]></title>
      <url>%2F2017%2F12%2F02%2F20171202%2F</url>
      <content type="text"><![CDATA[喂，你敢喜欢我吗(飞碟说)你……我…… 一梦醒,一梦空…… 2017.12.10 +1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Byteland_Trip]]></title>
      <url>%2F2017%2F11%2F30%2Fgym-101611B%2F</url>
      <content type="text"><![CDATA[题目传送门题意:略……$l[i][j]$表示从左边开始的前$i$个字符组成$j$个向右的半环的方案数.$r[i][j]$表示从右边开始的前$i$个字符组成$j$个向左的半环的方案数.然后就可以愉快的转移了……然后就可以枚举终点愉快的统计答案了……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 5005;void add(int &amp;x,int y) &#123; x += y; if(x &gt;= mod) x -= mod;&#125;int mul(int x,int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int p[maxn],l[maxn][maxn],r[maxn][maxn];char s[maxn];int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,i,j; scanf(&quot;%s&quot;,s); n = strlen(s); for(p[0] = i = 1;i &lt;= n; i++) p[i] = mul(i,p[i - 1]); if(n == 1) return puts(&quot;1&quot;); l[1][1] = (s[0] == &apos;&gt;&apos;); for(i = 1;i &lt; n; i++) &#123; for(j = 1;j &lt;= i; j++) add(l[i + 1][j],mul(l[i][j],j)); if(s[i] == &apos;&lt;&apos;) &#123; for(j = 2;j &lt;= i; j++) add(l[i + 1][j - 1],mul(l[i][j],mul(j,j - 1))); &#125; else &#123; for(j = 1;j &lt;= i; j++) add(l[i + 1][j + 1],l[i][j]); &#125; &#125; reverse(s,s + n); r[1][1] = (s[0] == &apos;&lt;&apos;); for(i = 1;i &lt; n; i++) &#123; for(j = 1;j &lt;= i; j++) add(r[i + 1][j],mul(r[i][j],j)); if(s[i] == &apos;&gt;&apos;) &#123; for(j = 2;j &lt;= i; j++) add(r[i + 1][j - 1],mul(r[i][j],mul(j,j - 1))); &#125; else &#123; for(j = 1;j &lt;= i; j++) add(r[i + 1][j + 1],r[i][j]); &#125; &#125; for(i = 1;i &lt;= n; i++) &#123; if(i == 1) printf(&quot;%d &quot;,r[n - 1][1]); else if(i == n) printf(&quot;%d &quot;,l[n - 1][1]); else &#123; int ans = 0; for(j = 1;j &lt; i; j++) &#123; add(ans,mul(mul(mul(l[i - 1][j],r[n - i][j]),mul(p[j],p[j])),2)); add(ans,mul(mul(l[i - 1][j],r[n - i][j + 1]),mul(p[j],p[j + 1]))); add(ans,mul(mul(l[i - 1][j + 1],r[n - i][j]),mul(p[j],p[j + 1]))); &#125; printf(&quot;%d &quot;,ans); &#125; &#125; puts(&quot;&quot;); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hihocoder1635_Colored_Nodes]]></title>
      <url>%2F2017%2F11%2F30%2Fbeijing-icpc-i%2F</url>
      <content type="text"><![CDATA[题目传送门题意:略……暴力染色一轮,然后可以得到每个点的颜色是从哪个点转移过来的,类似于等到了一个点的颜色转移矩阵.如果点$i$的前驱是$fa_{i}$,则连边$fa_{i}-&gt;i$,然后可以得到一些基环外向树,可以知道每棵树只有一个环,树上的点的颜色会被环上的点等频率的染色到.然后把每棵树重新定义一种颜色,模拟一轮染色,就可以得到这棵树在一轮染色中占有了的点的个数.一轮染色染$n$次,总共$n^{2}$个点.那么每棵树的答案即是$\frac{sum}{num * n}$,$sum$为占有的点的个数,$num$为环上点的个数.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;vector&lt;int&gt; g[maxn];vector&lt;double&gt; ans;int c[maxn],d[maxn],pre[maxn],cnum[maxn],tot,col;LL csum[maxn];int dfs(int u) &#123; if(d[u] == -1) &#123; d[u] = col++; cnum[d[u]]++; return u; &#125; else if(d[u]) return 0; d[u] = -1; int dx = dfs(c[u]); d[u] = d[c[u]]; if(dx == 0 || dx == u) return 0; else &#123; cnum[d[u]]++; return dx; &#125;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,m,i,u,v; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; for(i = 1; i &lt;= n; i++) &#123; g[i].clear(); c[i] = i; &#125; memset(pre,0,sizeof(pre)); memset(d,0,sizeof(d)); memset(csum,0,sizeof(csum)); memset(cnum,0,sizeof(cnum)); ans.clear(); for(i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); g[u].push_back(v); g[v].push_back(u); &#125; for(i = 1; i &lt;= n; i++) &#123; for(auto x:g[i]) c[x] = c[i]; &#125; for(i = col = 1; i &lt;= n; i++) &#123; if(!d[i]) dfs(i); &#125; for(i = 1; i &lt;= n; i++) &#123; for(auto x:g[i]) &#123; if(d[x] != d[i]) &#123; csum[d[x]] += i - pre[x]; d[x] = d[i]; pre[x] = i; &#125; &#125; &#125; for(i = 1; i &lt;= n; i++) csum[d[i]] += n - pre[i]; for(i = 1; i &lt; col; i++) &#123; double fs = 1.0 * csum[i] / n / cnum[i]; for(v = 0; v &lt; cnum[i]; v++) ans.push_back(fs); &#125; sort(ans.rbegin(),ans.rend()); for(auto x:ans) printf(&quot;%.6f\n&quot;,x); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[F.Fygon_2.0]]></title>
      <url>%2F2017%2F11%2F28%2F2017_NEERC_F%2F</url>
      <content type="text"><![CDATA[题意: 给你一些$for$的嵌套表达式,求渐近复杂度分析: 如果是$for(i:1-&gt;n) for(j:i-&gt;n) for(k:j-&gt;n) \dots$的形式,那么我们可以知道其复杂度是$\frac{n^{m}}{m!}$,然而其它的表达式形式都可以拆成多个这样的形式的和,那么就转化为能有多少组这样的形式,如果把给的$for(a:b-&gt;c)$转换为两条边$b-&gt;a,a-&gt;c$,那么就变成图的拓扑序个数,当然我们可能遇到环,把环缩点掉就好了(因为环表示环上所有点的值都相同) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;map&lt;char,int&gt; q;int tot = 0;int fa[22],h[22],g[22][22];LL f[1 &lt;&lt; 20];int get_id(char x) &#123; if(x == &apos;1&apos; || x == &apos;n&apos;) return -1; if(!q.count(x)) q[x] = tot++; return q[x];&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif freopen(&quot;fygon20.in&quot;, &quot;r&quot;, stdin); freopen(&quot;fygon20.out&quot;, &quot;w&quot;, stdout); int n,i,j,k,u,l,r; char s[22]; scanf(&quot;%d&quot;,&amp;n); for(i = 1;i &lt; n; i++) &#123; scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,s); u = get_id(s[0]); scanf(&quot;%s&quot;,s); scanf(&quot;%s&quot;,s); l = get_id(s[6]); scanf(&quot;%s&quot;,s); r = get_id(s[0]); if(~l) fa[u] |= 1 &lt;&lt; l,g[l][u] = 1; if(~r) fa[r] |= 1 &lt;&lt; u,g[u][r] = 1; &#125; for(i = 0;i &lt; tot; i++) &#123; for(j = 0;j &lt; tot; j++) &#123; for(k = 0;k &lt; tot; k++) g[j][k] |= g[j][i] &amp; g[i][k]; &#125; &#125; n--; for(i = 0;i &lt; tot; i++) &#123; if(h[i] == -1) continue; h[i] |= 1 &lt;&lt; i; for(j = i + 1;j &lt; tot; j++) &#123; if(g[i][j] &amp;&amp; g[j][i]) &#123; h[i] |= 1 &lt;&lt; j,h[j] = -1; n--; fa[i] |= fa[j]; &#125; &#125; fa[i] ^= fa[i] &amp; h[i]; &#125; f[0] = 1; for(i = 0;i &lt; (1 &lt;&lt; tot); i++) &#123; if(f[i]) &#123; for(j = 0;j &lt; tot; j++) &#123; if(!((i &gt;&gt; j) &amp; 1) &amp;&amp; ((i &amp; fa[j]) == fa[j])) f[i | h[j]] += f[i]; &#125; &#125; &#125; LL a = 1,b = f[(1 &lt;&lt; tot) - 1]; for(i = 2;i &lt;= n; i++) a *= i; LL g = __gcd(a,b); printf(&quot;%d %lld/%lld\n&quot;,n,b / g,a / g); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hihocoder1629_Graph]]></title>
      <url>%2F2017%2F11%2F23%2Fbeijing-icpc-c%2F</url>
      <content type="text"><![CDATA[题目传送门题意: 给你一个带标号的无向图,有$q$次询问,每次询问区间$[L,R]$内有多少对点联通并且该路径上所有点都在这个区间内.按端点从小到大的顺序加边,每条边加两次,然后能得到一个边序列,同时能处理出每个点所属的边的区间$[l_{i},r_{i}]$,对于一个询问$[L,R]$,即询问边序列上区间$[l_{L},r_{R}]$内两个端点都在$[L,R]$内的那些边组成的图的答案.然后把这个边序列分块,用类似莫队的思想处理询问,只是把减操作变成了还原操作,用按秩合并的并查集维护联通块个数即可.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//created by missever#include&lt;bits/stdc++.h&gt;#define fi first#define se secondusing namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;const int b_size = 333;P p[maxn];vector&lt;int&gt; g[maxn];int l[maxn],r[maxn],id[maxn],lim[maxn];LL ans[maxn];struct que &#123; int l,r,id;&#125; fq[maxn];bool cmp(const que &amp;a,const que &amp;b) &#123; if(id[l[a.l]] == id[l[b.l]]) return r[a.r] &lt; r[b.r]; else return id[l[a.l]] &lt; id[l[b.l]];&#125;struct union_find &#123; int f[maxn],rk[maxn],num[maxn],tot; P res[maxn]; LL ans; void init(int n) &#123; for(int i = 0; i &lt;= n; i++) f[i] = i,rk[i] = num[i] = 1; ans = tot = 0; &#125; int ff(int x) &#123; while(f[x] != x) x = f[x]; return x; &#125; void do_union(int x,int y) &#123; x = ff(x); y = ff(y); if(x == y) return; if(rk[x] &lt; rk[y]) swap(x,y); res[tot++] = P(y,rk[x]); f[y] = x; ans += 1LL * num[x] * num[y]; num[x] += num[y]; rk[x] = max(rk[x],rk[y] + 1); &#125; void back(int m) &#123; int x,y; while(tot &gt; m) &#123; tot--; y = res[tot].fi; x = f[y]; rk[x] = res[tot].se; num[x] -= num[y]; ans -= 1LL * num[x] * num[y]; f[y] = y; &#125; &#125;&#125; uf;void solve() &#123; int n,m,q,i,j,pre,k,x,y; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(i = 1; i &lt;= n; i++) g[i].clear(); for(i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; for(i = 1,m = -1;i &lt;= n; i++) &#123; l[i] = m + 1; for(auto v:g[i]) &#123; if(v &gt; i) p[++m] = P(i,v); else p[++m] = P(v,i); lim[m] = i; &#125; r[i] = m; &#125; for(i = j = 0,k = 1;i &lt;= m; i++) &#123; if(++j == b_size) k++,j = 0; id[i] = k; &#125; for(i = 0; i &lt; q; i++) &#123; scanf(&quot;%d%d&quot;,&amp;fq[i].l,&amp;fq[i].r); fq[i].id = i; &#125; sort(fq,fq + q,cmp); i = 0; while(i &lt; q) &#123; k = id[l[fq[i].l]]; uf.init(n); pre = 0; x = y = min(k * b_size,m + 1); while(i &lt; q &amp;&amp; id[l[fq[i].l]] == k) &#123; if(id[r[fq[i].r]] &lt;= k) &#123; for(j = l[fq[i].l];j &lt;= r[fq[i].r]; j++) &#123; if(fq[i].l &lt;= p[j].fi &amp;&amp; p[j].se &lt;= fq[i].r) uf.do_union(p[j].fi,p[j].se); &#125; &#125; else &#123; while(x &lt;= r[fq[i].r]) &#123; if(lim[y] &lt;= p[x].fi &amp;&amp; p[x].se &lt;= fq[i].r) uf.do_union(p[x].fi,p[x].se); x++; &#125; pre = uf.tot; for(j = l[fq[i].l];j &lt; y; j++) &#123; if(fq[i].l &lt;= p[j].fi &amp;&amp; p[j].se &lt;= fq[i].r) uf.do_union(p[j].fi,p[j].se); &#125; &#125; ans[fq[i++].id] = uf.ans; uf.back(pre); &#125; &#125; for(i = 0;i &lt; q; i++) printf(&quot;%lld\n&quot;,ans[i]);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t; scanf(&quot;%d&quot;,&amp;t); while(t--) solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#446(Div. 1)_E]]></title>
      <url>%2F2017%2F11%2F22%2FCF_446_E%2F</url>
      <content type="text"><![CDATA[题目传送门题意: 给你一个序列并执行$k$次操作,每次选择一个数减一,并给$res$加上其它数的乘积,求最后$res$的期望值分析: 思考一下就会发现,对于每种操作方案,最后的$res$都是初始序列各数的乘积减去操作完后各数乘积.所以最后的期望答案就是$ans = \prod_{i=1}^{n}a_{i} - k!/ n^{k} \sum_{\sum_{i=1}^{n}x_{i}=k}\prod_{i=1}^{n}(a_{i} - x_{i})/x_{i}!$我们可以发现上述式子中存在一个卷积,并且存在分母为阶乘的分式,那么就可以很自然的想到指数型生成函数.因为$\sum (a_{i} - j)x^{j}/j!=(a_{i} - x)e^{x}$,所以有$ans=\prod_{i=1}^{n}a_{i} - k!/ n^{k}e^{nx}\prod_{i=1}^{n}(a_{i} - x)$,我们只需要求出这个生成函数的第$x^{k}$项的系数即可.通过$n^{2}$暴力求解最右边的连乘,然后枚举连乘部分所占的指数系数大小即可求得答案.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int add(int x,int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x,int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int powt(int a,int b) &#123; int r = 1; while(b) &#123; if(b &amp; 1) r = mul(r,a); a = mul(a,a); b &gt;&gt;= 1; &#125; return r;&#125;int a[5005],f[5005];int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,k,i,j,u,s,ans = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(i = 0,s = f[0] = 1;i &lt; n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); s = mul(s,a[i]); for(j = i;j &gt;= 0; j--) &#123; f[j + 1] = add(f[j + 1],mod - f[j]); f[j] = mul(f[j],a[i]); &#125; &#125; for(i = 0,u = 1;i &lt;= min(k,n); i++) &#123; ans = add(ans,mul(mul(u,f[i]),powt(n,k - i))); u = mul(u,k - i); &#125; ans = add(s,mod - mul(ans,powt(powt(n,k),mod - 2))); printf(&quot;%d\n&quot;,ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#443(Div. 1)_E]]></title>
      <url>%2F2017%2F11%2F13%2FCF_443_E%2F</url>
      <content type="text"><![CDATA[题目传送门443的D的思路非常的新奇呀,将数的大小关系用二进制位表示了出来题意:给你一个长度为$n$的序列$a$和$q$次询问,每次询问一个区间$[l,r]$,将这个区间提出来,执行以下操作:对于相邻两个数字$x,y$,删除$y$并将$x$替换为$x+2y$,问最后剩下的那个数最大为多少,答案模$1e9+7$分析: $ans = \sum_{i=0}^{m}a_{l+i}2^{k_{i}}$,除了$k_{0}=0$,这个$k$序列是由一些从$1$开始的连续自然数串组成的,例如$1,2,3 \dots 1,2 \dots$,如果我们能找出这些$1$的位置,那么答案就很好求了.我们通过枚举后缀来求$1$的位置,考虑一段区间,如果$\sum_{i=l}^{r}a_{i}2^{l - i}$大于$2e9$,那么不管前面的数是什么,该值都会变大,它的$1$的位置应该为$0$,若这个和小于$0$,那么$1$的位置就是$l-1$.对于一段长度为$m$区间,$1$的个数最多为$m$个,所以我们需要使用倍增来维护向前跳了$2^{k}$个$1$之后的位置.感觉自己都不知道自己在讲些什么1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;int add(int x,int y) &#123; x += y; if(x &gt;= mod) x -= mod; return x;&#125;int mul(int x,int y) &#123; LL z = 1LL * x * y; return z - z / mod * mod;&#125;int a[maxn],s[maxn],p[maxn],inv[maxn];int f[maxn][20],d[maxn][20];int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,q,i,j,l,r; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(i = p[0] = inv[0] = 1;i &lt;= n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); inv[i] = mul(inv[i - 1],500000004); p[i] = mul(p[i - 1],2); s[i] = add(s[i - 1],mul(mod + a[i],p[i])); &#125; for(i = 1;i &lt;= n; i++) &#123; LL x = 0; for(j = i;j &gt; 0; j--) &#123; x = (x * 2 + a[j]); if(x &lt;= 0) &#123; f[i][0] = j - 1; d[i][0] = add(0,mod + x * 2 % mod); break; &#125; if(x &gt; 2000000000) &#123; f[i][0] = -1; break; &#125; &#125; &#125; for(j = 1;j &lt; 18; j++) &#123; for(i = 1;i &lt;= n; i++) &#123; if(f[i][j - 1] == -1) f[i][j] = -1; else &#123; f[i][j] = f[f[i][j - 1]][j - 1]; d[i][j] = add(d[i][j - 1],d[f[i][j - 1]][j - 1]); &#125; &#125; &#125; while(q--) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); int ans = 0; for(i = 17;i &gt;= 0; i--) &#123; if(f[r][i] &gt; l) &#123; ans = add(ans,d[r][i]); r = f[r][i]; &#125; &#125; if(r &gt;= l) ans = add(ans,mul(add(s[r],mod - s[l - 1]),inv[l])); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#445(Div. 1)_E]]></title>
      <url>%2F2017%2F11%2F11%2FCF_445_E%2F</url>
      <content type="text"><![CDATA[题目传送门比赛打到一半CF炸了,感觉非常的累……题意:给你序列$a_{i}$,定义$f(x,n)=x \% a_{n},f(x,i)=x \% a_{i} + f(x \% a_{i},i + 1)$,求函数$f(x,1)$的最大值.分析:$f(x,1)=x \% a_{1} + x \% a_{1} \% a_{2} + \dots + x \% a_{1} \% a_{2} \dots \% a_{n}$,定义$b_{x,i} = x \% a_{1} \% a_{2} \dots \% a_{i}$.定理: 如果$f(m,1)$是最大值,那么一定存在至少一个$i$使得$b_{m,i} = a_{i} - 1$.证明:反证法,如果$f(m,1)$是最大值且不满足上述条件,那么对于$f(m + 1,1)$,我们可以得到$b_{m+1,i} = b_{m,i} + 1$,那么$f(m,1)$就肯定不是最大值,得证.做法: 用$map$维护一个$pair(c,w)$表示当$0 \leq b_{x,i} \leq c$时,前$i$个数的比$c$多的部分的和的最大值.当$a_{i} &gt; c$时$w$不变;当$a_{i} \leq c$时区间由$[0,c]$变成$[0,a_{i}-1],[0,c \% a_{i}]$.答案就是$max(w + c * n)$ 123456789101112131415161718192021222324252627282930313233343536373839//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;LL,LL&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;map&lt;LL,LL&gt; q;vector&lt;P&gt; f;int main()&#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,i; LL x,p; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%lld&quot;,&amp;p); q[p - 1] = 0; for(i = 1;i &lt; n; i++) &#123; scanf(&quot;%lld&quot;,&amp;x); if(x &gt;= p) continue; f.clear(); auto e = q.lower_bound(x); for(auto u = e;u != q.end(); u++) f.push_back(*u); q.erase(e,q.end()); for(auto u:f) &#123; q[x - 1] = max(q[x - 1],(u.first - x + 1) / x * x * i + u.second); q[u.first % x] = max(q[u.first % x],u.first / x * x * i + u.second); &#125; &#125; x = 0; for(auto e:q) x = max(x,e.first * n + e.second); printf(&quot;%lld\n&quot;,x); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博= =客]]></title>
      <url>%2F2017%2F11%2F09%2Fthe-second-article%2F</url>
      <content type="text"><![CDATA[11.09给博客瞎搞了一个评论功能弄了上去……虽然好像兼容性不是特别的好，就这样吧(反正也觉得没人会评论的)搜索功能似乎至少要输入两个字才行……感觉非常的捉急 11.13那个友言似乎登不上去呀……默默的换成畅言试一下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[青花引]]></title>
      <url>%2F2017%2F11%2F02%2Fsong-qinghuayin%2F</url>
      <content type="text"><![CDATA[一壶青花清水细撩蒹葭淋漓飒沓世外尽喧哗烟景细尘吹过咿咿呀呀琉璃灯下私语话一点朱砂春来秋去韶华古道遥遥牡丹亭外花风醇柔火千古灼烧不肯罢纹上锦鲤戏软纱慷慨够几话座上天下此番辗转天涯伏笔够几话一笔江枫一笔山隐结发眼过几冬夏 灰烬归家也再无双生花昌南夜雨凉透瓶身骨中化便装下茶的清雅酒的潇洒唐诗宋词浓墨重彩遥遥等春发只劝岁月少几寸浮夸当流光遇流萤染了白月牙宫商广寒鸦一身飒飒无瑕唇齿猎眉峰仕女簪花自逐岸上白马别了烂漫飞花萍踪浪迹谁人踏高山流水未达忽如远行才知江山如画尽归旁人羡煞而相思喑哑如她清平调起偏逢簌簌雪花不问千秋风流真或假春来花发袖中点点新芽浓淡跃然灯火又万家眠我情话鸾凤和鸣碎烟霞更长漏永雁平沙慷慨够几话座上天下此番辗转天涯伏笔够几话一笔江枫一笔山隐结发眼过几冬夏灰烬归家也再无双生花昌南夜雨凉透瓶身骨中化便装下茶的清雅酒的潇洒唐诗宋词浓墨重彩遥遥等春发只劝岁月少几寸浮夸当流光遇流萤染了白月牙宫商广寒鸦一身飒飒无瑕唇齿猎眉峰仕女簪花自逐岸上白马别了烂漫飞花昌南夜雨凉透瓶身骨中化便装下茶的清雅酒的潇洒唐诗宋词浓墨重彩遥遥等春发只劝岁月少几寸浮夸当流光遇流萤染了白月牙宫商广寒鸦一身飒飒无瑕唇齿猎眉峰仕女簪花自逐岸上白马别了烂漫飞花炉火白釉 青瓷花 水墨青花徐志摩轻吟一句情话，执笔一副情画。绽放一地情花，覆盖一片青瓦。共饮一杯清茶，同研一碗青砂。挽起一面轻纱，看清天边月牙。爱像水墨青花，何惧刹那芳华。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[葬仙]]></title>
      <url>%2F2017%2F10%2F02%2Fsong-zangxian%2F</url>
      <content type="text"><![CDATA[倾覆八荒血染剑上一寸霜被万灵膜拜白衣世无双鬼面似笑又好似心伤这是宿命在逼迫我反抗永生执念寻觅相似花绽放那少年惊艳岁月争星芒仙路迢迢 枯骨路成王这是英雄他生来的战场 我曾背负世人谎血衣大杀过四方我曾望着星光伴一人而唱 我曾只手遮天光游走宇宙过洪荒我曾祈求天地与万物 护你佑你无恙 你可无恙？ 永生执念寻觅相似花绽放那少年惊艳岁月争星芒仙路迢迢 枯骨路成王这是英雄他生来的战场我曾背负世人谎血衣大杀过四方我曾望着星光伴一人流浪我曾只手遮天光游走宇宙过洪荒我曾傲然天地与万物念你无恙 我曾背负世人妄暮色疲惫过丘芒我曾揽月摘星将一人殡葬 我曾覆手镇魍魉改写生死逆苍穹我曾震慑千古却只为重回昆仑山上 将故人葬]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[佩尔方程]]></title>
      <url>%2F2017%2F10%2F02%2FPell%2F</url>
      <content type="text"><![CDATA[连分数$\omega = a_{0} + \frac{1}{a_{1} + \frac{1}{a_{2} + \cdots }}$一个实数 $\omega$ 可以用一个正整数数列$\left[a_{i} \right]$表示，这样的表示方法称为连分数表示.有理数的连分数序列有限，无理数的连分数序列无限.给定$\left[a_{i} \right]$数列，求原数$\frac{p_{n}}{q_{n}}$的递推公式：$p_{n} = a_{n}p_{n-1}+p_{n-2},p_{-1}=1,p_{-2}=0$$q_{n} = a_{n}q_{n-1}+q_{n-2},q_{-1}=0,q_{-2}=1$一个实数的序列长度为$n$连分数表示亦称为一个数的$n$渐近分数. 佩尔(Pell)方程$x^{2}-Ny^{2}=1$佩尔方程有解的充要条件是正整数$N$不是完全平方数定理：若$\sqrt N$的渐近分数为$\frac{p_{k}}{q_{k}}$,则存在$n&gt;0$，使得$p_{n}^{2}-Nq_{n}^{2}=1$递推寻找最小解：初始化：$p_{-1}=1,p_{-2}=0$$q_{-1}=0,q_{-2}=1$$a_{0}=\left \lfloor \sqrt{N} \right \rfloor$$g_{-1}=0,h_{-1}=1$递推寻找：$g_{i}=-g_{i-1}+a_{i}h_{i-1}$$h_{i}=\frac{N-g_{i}^{2}}{h_{i-1}}$$a_{i+1}=\left \lfloor \frac{g_{i}+a_{0}}{h_{i}} \right \rfloor$$p_{i}=a_{i}p_{i-1}+p_{i-2}$$q_{i}=a_{i}q_{i-1}+q_{i-2}$然后check $p_{i},q_{i}$ 如果求得了最小解$x_{1},y_{1}$,那么可以递推出第$k$大解：$x_{k}=x_{k-1}x_{1}+Ny_{k-1}y_{1}$$y_{k}=x_{k-1}y_{1}+y_{k-1}x_{1}$并且第$k$大解$(x_{k},y_{k})$满足$x_{k}+\sqrt{N}y_{k}=(x_{1}+\sqrt{N}y_{1})^{k}$所以当$k$比较大时,可以使用二元域的快速幂求解 第二类佩尔方程$x^{2}-Ny^{2}=-1$若上式有解,设其最小解为$(x_{0},y_{0})$,那么上式的所有解$(x_{k},y_{k})$满足$x_{k}+y_{k}\sqrt{N}=(x_{0}+y_{0}\sqrt{N})^{2k+1}$设$x^{2}-Ny^{2}=1$的最小解为$(a,b)$,满足$a+b\sqrt{N}=(x_{0}+y_{0}\sqrt{N})^{2}$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017北京网络赛补]]></title>
      <url>%2F2017%2F10%2F02%2FBeijing2017%2F</url>
      <content type="text"><![CDATA[D.Agent Communication题意：给你一棵树,你需要加一条边,使得所有点对的距离的最大值最小.分析：加的边一定在直径上,先处理出所有点到直径的距离,然后仿照hdu5699即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1005;vector&lt;int&gt; g[maxn],f;int d[maxn],w[maxn];bool inl[maxn];int dfs(int u,int fa) &#123; int x,k = u; for(auto v:g[u]) &#123; if(v == fa || inl[v]) continue; d[v] = d[u] + 1; x = dfs(v,u); if(d[x] &gt; d[k]) k = x; &#125; return k;&#125;bool dfs(int u,int fa,int w) &#123; f.push_back(u); inl[u] = 1; if(u == w) return true; for(auto v:g[u]) &#123; if(v == fa) continue; if(dfs(v,u,w)) return true; &#125; f.pop_back(); inl[u] = 0; return false;&#125;bool check(int k,int m) &#123; int i,j,u,l1,l2,r1,r2; l1 = l2 = -mod; r1 = r2 = mod; for(i = 0;i &lt; m; i++) &#123; for(j = i + 1;j &lt; m; j++) &#123; if(j - i + w[i] +w[j] &lt;= k) continue; u = k - 1 - w[i] - w[j]; l1 = max(l1,i + j - u); l2 = max(l2,j - i - u); r1 = min(r1,i + j + u); r2 = min(r2,j - i + u); &#125; &#125; if(l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) &#123; if(l1 == r1 &amp;&amp; l2 == r2) &#123; if((l1 + l2) &amp; 1) return false; else return true; &#125; else return true; &#125; else return false;&#125;void solve() &#123; int n,m,u,v,i,l,r,mid; scanf(&quot;%d&quot;,&amp;n); for(i = 1;i &lt;= n; i++) g[i].clear(); memset(inl,0,sizeof(inl)); for(i = 1;i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); g[u].push_back(v); g[v].push_back(u); &#125; d[1] = 1; u = dfs(1,0); d[u] = 1; v = dfs(u,0); f.clear(); dfs(u,0,v); m = f.size(); for(i = 0;i &lt; m; i++) &#123; d[f[i]] = 0; w[i] = d[dfs(f[i],0)]; &#125; l = 0; r = 1005; while(l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if(check(mid,m)) r = mid; else l = mid + 1; &#125; printf(&quot;%d\n&quot;,r);&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t; scanf(&quot;%d&quot;,&amp;t); while(t--) solve(); return 0;&#125; F.Cake题意：有三个人在做$n$个蛋糕,每个蛋糕分三步,每人负责一步,只能做完上一步才能做下一步.每个人做的顺序必须一致,问最小总时间.分析：对于两个蛋糕A和B，定义$A &lt; B$,当且仅当AB相邻时AB比BA要优。然后排序完跑一遍就行了12345678910111213141516171819202122232425262728293031323334353637383940414243//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;struct node &#123; int a,b,c;&#125; f[maxn];bool cmp(const node &amp;x,const node &amp;y) &#123; int u = max(x.a + x.b,x.a + y.a); u = max(u + y.b,x.a + x.b + x.c) + y.c; int v = max(y.a + y.b,y.a + x.a); v = max(v + x.b,y.a + y.b + y.c) + x.c; return u &lt; v;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int n,i; LL da,db,dc; while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; for(i = 0;i &lt; n; i++) scanf(&quot;%d%d%d&quot;,&amp;f[i].a,&amp;f[i].b,&amp;f[i].c); sort(f,f + n,cmp); da = db = dc = 0; for(i = 0;i &lt; n; i++) &#123; da += f[i].a; db = max(db,da); db += f[i].b; dc = max(dc,db); dc += f[i].c; &#125; printf(&quot;%lld\n&quot;,dc); &#125; return 0;&#125; H.Polynomial Product题意：给你两个多项式,定义卷积后的系数$c_{i}= max(a_{j}+b_{i-j})$,问哪些系数大于了$w$分析：排序之后,可以线性处理出对于$a_{i}$有哪些$b_{j}$会使得它们的和大于$w$,然后用$bitset$取一遍或,即可.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//created by missever#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int mod = 1e9 + 7;const int maxn = 1e5 + 5;vector&lt;P&gt; fa,fb;bitset&lt;1005&gt; v1,ans1;bitset&lt;maxn&gt; v2,ans2;void solve(int t) &#123; int n,m,w,x,i,j; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;w); fa.clear(); fb.clear(); for(i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;,&amp;x); if(x == 0) continue; if(x == 1) x = 0; fa.push_back(P(x,i)); &#125; for(i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;,&amp;x); if(x == 0) continue; if(x == 1) x = 0; fb.push_back(P(x,i)); &#125; x = n + m - 1; sort(fa.begin(),fa.end()); sort(fb.begin(),fb.end()); n = fa.size(); m = fb.size(); if(n &gt; m) &#123; swap(n,m); swap(fa,fb); &#125; if(t &lt; 4) &#123; v2.reset(); ans2.reset(); for(i = 0,j = m - 1; i &lt; n; i++) &#123; while(j &gt;= 0 &amp;&amp; (LL)fb[j].first + fa[i].first &gt; w) v2[fb[j--].second] = 1; ans2 |= v2 &lt;&lt; fa[i].second; &#125; for(i = 0; i &lt; x; i++) putchar(ans2[i] ? &apos;Y&apos; : &apos;N&apos;); puts(&quot;&quot;); &#125; else &#123; v1.reset(); ans1.reset(); for(i = 0,j = m - 1; i &lt; n; i++) &#123; while(j &gt;= 0 &amp;&amp; (LL)fb[j].first + fa[i].first &gt; w) v1[fb[j--].second] = 1; ans1 |= v1 &lt;&lt; fa[i].second; &#125; for(i = 0; i &lt; x; i++) putchar(ans1[i] ? &apos;Y&apos; : &apos;N&apos;); puts(&quot;&quot;); &#125;&#125;int main() &#123;#ifdef CX_TEST freopen(&quot;E:\\program--GG\\test_in.txt&quot;, &quot;r&quot;, stdin);#endif int t; scanf(&quot;%d&quot;,&amp;t); while(t--) solve(t); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Dividing_Area]]></title>
      <url>%2F2017%2F07%2F10%2Fgym-101237J%2F</url>
      <content type="text"><![CDATA[题目传送门题意：给你$n$个点，有$Q$次操作，操作分别为在两个点之间连一条边和询问在一条边左边的相邻的封闭图形的面积。并且最后$n$个点会形成一个平面图。我们把操作离线，对最后的平面图进行转对偶图操作，把每条边拆成两条单向边，并且用并查集把有向边左边的空白区域和该边连接起来，树根为空白区域，并记录空白区域面积。然后倒着操作，如果是加边操作，则删除该边，并把两个有向边所相邻的空白区域用并查集合并，查询面积操作即访问树根即可。NOTE：极角排序写挫了、、RE20不能自拔……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;typedef pair&lt;double,int&gt; PD;const int maxn = 1e6 + 5;const double eps = 1e-10;const double pi = acos(-1);inline int sgn(double x) &#123; if(x &lt; -eps) return -1; else if(x &gt; eps) return 1; else return 0;&#125;struct Point &#123; int x,y; Point(int _x = 0,int _y = 0): x(_x),y(_y) &#123;&#125; Point operator + (const Point &amp;b) const &#123; return Point(x + b.x,y + b.y); &#125; Point operator - (const Point &amp;b) const &#123; return Point(x - b.x,y - b.y); &#125; LL operator * (const Point &amp;b) const &#123; return (1LL * x * b.x + 1LL * y * b.y); &#125; LL operator ^ (const Point &amp;b) const &#123; return (1LL * x * b.y - 1LL * y * b.x); &#125;&#125;;Point p[maxn];P f[maxn];struct que &#123; int op,u,v; que(int _op = 0,int _u = 0,int _v = 0): op(_op),u(_u),v(_v) &#123;&#125;&#125; q[maxn];int n,tot = 0;bool vis[maxn * 2];map&lt;P,int&gt; mp;vector&lt;PD&gt; g[maxn];int df[maxn * 4];map&lt;int,LL&gt; mpp;map&lt;int,int&gt; gg[maxn];LL sm = 0;int sk;LL ans[maxn];double get_ang(int u,int v) &#123; return atan2(p[v].y - p[u].y,p[v].x - p[u].x);&#125;int fff(int x) &#123; if(df[x] != x) df[x] = fff(df[x]); return df[x];&#125;void work(int u,PD e) &#123; int v1 = u,v2 = e.second,k = 0; f[k++] = P(v1,v2); while(v2 != u) &#123; v1 = gg[v2][v1]; if(v1 == 0) v1 = g[v2].back().second; else v1 = g[v2][v1 - 1].second; swap(v1,v2); f[k++] = P(v1,v2); &#125; LL ss = 0; for(int i = 0; i &lt; k; i++) ss += p[f[i].first] ^ p[f[i].second]; if(ss &lt;= 0) mpp[tot] = -1; else mpp[tot] = ss; df[tot] = tot; for(int i = 0; i &lt; k; i++) &#123; int j = mp[f[i]]; vis[j] = 1; df[j] = tot; &#125; tot++;&#125;bool cmp(const PD &amp;a,const PD &amp;b)&#123; if(sgn(b.first - a.first) == 0) return ((p[b.second] - p[sk]) ^ (p[a.second] - p[sk])) &lt; 0; else return b.first - a.first &gt; eps;&#125;void build() &#123; int i,j; for(i = 1; i &lt;= n; i++)&#123; sk = i; sort(g[i].begin(),g[i].end(),cmp); for(j = 0;j &lt; g[i].size(); j++) gg[i][g[i][j].second] = j; &#125; for(i = 1; i &lt;= n; i++) &#123; for(auto e:g[i]) &#123; j = mp[P(i,e.second)]; if(vis[j]) continue; work(i,e); &#125; &#125;&#125;int main() &#123; int Q,i,op,u,v; scanf(&quot;%d&quot;,&amp;n); for(i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;,&amp;p[i].x,&amp;p[i].y); scanf(&quot;%d&quot;,&amp;Q); for(i = 1; i &lt;= Q; i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;u,&amp;v); u++; v++; q[i] = que(op,u,v); if(op == 1) &#123; g[u].push_back(PD(get_ang(u,v),v)); g[v].push_back(PD(get_ang(v,u),u)); mp[P(u,v)] = tot++; mp[P(v,u)] = tot++; &#125; &#125; build(); int tt = 0; for(i = Q; i &gt; 0; i--) &#123; if(q[i].op == 1) &#123; u = fff(mp[P(q[i].u,q[i].v)]); v = fff(mp[P(q[i].v,q[i].u)]); if(u == v) continue; if(mpp[u] == -1 || mpp[v] == -1) mpp[u] = -1; else mpp[u] += mpp[v]; df[v] = u; &#125; else &#123; u = fff(mp[P(q[i].u,q[i].v)]); ans[tt++] = mpp[u]; &#125; &#125; for(i = tt - 1; i &gt;= 0; i--) printf(&quot;%lld\n&quot;,ans[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#421(Div. 1)_D]]></title>
      <url>%2F2017%2F07%2F05%2FCF-421_D%2F</url>
      <content type="text"><![CDATA[题目传送门题意：外星球每隔T秒中只有一秒可以被观测到，其它T-1秒无法被观测。n个天文学家（分别编号为1,…,n）轮流观测天空1秒，且第i+1个科学家在第i个天文学家后ai+1秒后才执行观测，而第一个天文学家则在第n个天文学家后a1秒后才执行观测，且第一个天文学家在0秒时执行第一次观测（即第一个天文学家观测的时间是[0,1)，第二个科学家在[a2,a2+1)时观测，而最后一个天文学家在[a2+a3+…+an-1,a2+a3+…+an-1+1)时观测，之后再过a1秒后第一个天文学家继续观测）。由于外星球具体在首次观测之后的T秒中的哪一秒出现是不确定的，若外星球在[i,i+1)时出现（0&lt;=i&lt;T-1），且天文学家j是首个观测到星球的人，则称j抢占了[i,i+1)时间片段。已知T,n,a1,….,an其中(1&lt;=T&lt;=1e9，1&lt;=n&lt;=1e5，1&lt;=a1,…,an&lt;=1e9)。输出每个天文学家所抢占的时间片段数。 解法：把n个科学家分成多个组，每组的人的观测的时间点集合在模T之后是相同的，那么他们就构成了一个环，我们只需要对每个组排序，然后就可以愉快的算出各个科学家的时间片段数了。如何确定这名科学家在哪一组和组内的排序依靠建立同余方程，并用裴蜀定理和扩展欧几里德求解。懒得写了具体实现不如看官方题解23312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;typedef pair&lt;int,int&gt; P;const int maxn = 2e5 + 5;int a[maxn],tot,mm,ans[maxn];vector&lt;P&gt; g[maxn];unordered_map&lt;int,int&gt; mp;void extend_Euclid(int a, int b, int &amp;x, int &amp;y)&#123; if(b == 0) &#123; x = 1; y = 0; return; &#125; extend_Euclid(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a / b) * y;&#125;int get_modans(int a,int m,int b)&#123; if(a == 0) return 0; if(b == 0) return 0; int d = __gcd(a,m); int x,y; extend_Euclid(a / d,m / d,x,y); x = 1LL * x * b / d % m; x = (x % m + m) % m; x %= mm; return x;&#125;bool cmp(const P &amp;a,const P &amp;b)&#123; if(a.first == b.first) return a.second &gt; b.second; else return a.first &lt; b.first;&#125;void solve(vector&lt;P&gt; &amp;f)&#123; int n = f.size(); sort(f.begin(),f.end(),cmp); f.push_back(P(mm + f[0].first,0)); for(int i = 0;i &lt; n; i++) ans[f[i].second] = f[i + 1].first - f[i].first;&#125;int main()&#123; int t,n,i; scanf(&quot;%d%d&quot;,&amp;t,&amp;n); scanf(&quot;%d&quot;,&amp;a[n]); for(i = 1;i &lt; n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i = 1;i &lt;= n; i++)&#123; a[i] %= t; a[i] += a[i - 1]; if(a[i] &gt;= t) a[i] -= t; &#125; int k = __gcd(a[n] + t,t); mm = t / k; for(i = 0;i &lt; n; i++)&#123; int x = a[i] % k; if(mp[x] == 0) mp[x] = ++tot; g[mp[x]].push_back(P(get_modans(a[n],t,(a[i] - x + t) % t),i)); &#125; for(i = 1;i &lt;= tot; i++) solve(g[i]); for(i = 0;i &lt; n; i++) printf(&quot;%d &quot;,ans[i]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#415(Div. 1)_E]]></title>
      <url>%2F2017%2F06%2F14%2FCF-415_E%2F</url>
      <content type="text"><![CDATA[参考了一下大神的题解、、题解传送门：[https://blog.sengxian.com/solutions/cf-809e] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;const int maxn = 2e5 + 5;int n,rt;vector&lt;int&gt; g[maxn],g2[maxn],fac[maxn],vec[maxn];int cnt = 0,bn = 0,b[maxn * 2],a[maxn];int f[maxn * 2],dfn[maxn],dis[maxn],st[maxn];bool flag[maxn];int phi[maxn],pri[maxn],mu[maxn],inv[maxn],cc[maxn],xc[maxn];int tot = 0;void add(int &amp;x,int y) &#123; x += y; while(x &gt;= MAX) x -= MAX; while(x &lt; 0) x += MAX;&#125;int mod(int x,int y) &#123; LL z = 1LL * x * y; return z - z / MAX * MAX;&#125;void dfs(int u,int fa) &#123; int tmp = ++cnt; b[++bn] = tmp; f[tmp] = u; dfn[u] = bn; for(auto v:fac[a[u]]) vec[v].push_back(u); for (auto v:g[u]) &#123; if (v == fa) continue; dis[v] = dis[u] + 1; dfs(v,u); b[++bn] = tmp; &#125;&#125;int dp[maxn * 2][20];void rmq_init() &#123; int i,j; for (i = 1; i &lt;= bn; i++) dp[i][0] = b[i]; int m = floor(log(bn*1.0)/log(2.0)); for (j = 1; j &lt;= m; j++) for (i=1; i &lt;= bn-(1&lt;&lt;j)+1 ; i++) dp[i][j] = min(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);&#125;int rmq(int l,int r) &#123; int k = floor(log((r-l+1)*1.0)/log(2.0)); return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int lca(int x,int y) &#123; if(x == y) return x; if (dfn[x] &gt; dfn[y]) swap(x,y); int k = rmq(dfn[x],dfn[y]); return f[k];&#125;bool cmp(const int &amp;i, const int &amp;j) &#123; return dfn[i] &lt; dfn[j];&#125;void build_tree(vector&lt;int&gt; &amp;vc) &#123; int sz = 0,k = vc.size(); sort(vc.begin(),vc.end(),cmp); st[sz] = 0; g2[0].clear(); for (int i = 0; i &lt; k; ++i) &#123; int u = vc[i], ll = lca(u, st[sz]); g2[u].clear(); if (ll == st[sz]) st[++sz] = u; else &#123; while (sz &gt;= 1 &amp;&amp; dis[st[sz - 1]] &gt;= dis[ll]) &#123; g2[st[sz - 1]].push_back(st[sz]); sz--; &#125; if (st[sz] != ll) &#123; g2[ll].clear(); g2[ll].push_back(st[sz--]); st[++sz] = ll; &#125; st[++sz] = u; &#125; &#125; for (int i = 0; i &lt; sz; ++i) g2[st[i]].push_back(st[i + 1]);&#125;int dfs2(int u,int ff)&#123; int s1,s2; s1 = s2 = 0; xc[u] = (a[u] % ff == 0) ? phi[a[u]] : 0; for(auto v:g2[u])&#123; add(s1,dfs2(v,ff)); add(s2,mod(xc[u],xc[v])); add(xc[u],xc[v]); &#125; add(s1,mod(s2,2 * dis[u])); if(a[u] % ff == 0) add(s1,mod(dis[u],mod(phi[a[u]],phi[a[u]]))); return s1;&#125;void Get_phi() &#123; mu[1] = phi[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; if(!flag[i]) &#123; pri[tot++] = i; phi[i] = i - 1; mu[i] = -1; &#125; for(int j = 0; j &lt; tot; j++) &#123; if(i * pri[j] &gt; n) break; flag[i * pri[j]] = true; if(i % pri[j] == 0) &#123; mu[i * pri[j]] = 0; phi[i * pri[j]] = pri[j] * phi[i]; break; &#125; else &#123; phi[i * pri[j]] = (pri[j] - 1) * phi[i]; mu[i * pri[j]] = -mu[i]; &#125; &#125; &#125;&#125;int calc(int u) &#123; int s1,s2; s1 = s2 = 0; for(auto v:vec[u]) &#123; add(s1,phi[a[v]]); add(s2,mod(phi[a[v]],dis[v])); &#125; s1 = mod(2,mod(s1,s2)); build_tree(vec[u]); add(s1,-2 * dfs2(0,u)); return s1;&#125;void solve() &#123; Get_phi(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i; j &lt;= n; j += i) fac[j].push_back(i); &#125; inv[1] = 1; for(int i = 2; i &lt;= n; i++) add(inv[i],MAX - mod(MAX / i,inv[MAX % i])); dis[1] = 1; dfs(1,0); rmq_init(); for(int i = 1; i &lt;= n; i++) cc[i] = calc(i); int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; int s = 0; for(int j = 1; i * j &lt;= n; j++) add(s,mu[j] * cc[i * j]); add(ans,mod(mod(s,i),inv[phi[i]])); &#125; ans = mod(ans,mod(inv[n],inv[n - 1])); printf(&quot;%d\n&quot;,ans);&#125;int main() &#123; int i,u,v; scanf(&quot;%d&quot;,&amp;n); for(i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i = 1; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); g[u].push_back(v); g[v].push_back(u); &#125; solve(); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URAL-1894-Non-Flying-Weather]]></title>
      <url>%2F2017%2F06%2F14%2Fural1894%2F</url>
      <content type="text"><![CDATA[题意:给你两个相交的凸包，其中一个可以任意移动，问最少多久能使两个凸包分离前置技能点：闽科夫斯基和:设P和Q是两个凸包，则有闽科夫斯基和 P+Q={a+b|a∈P,b∈Q} ,闽科夫斯基差 P-Q={a-b|a∈P,b∈Q}性质：P+Q是一个凸包，同时也是P和Q的所有并踵点对的和的集合，P+Q顶点数不超过P和Q的顶点和其差P-Q是一个凸包，同时也是P和Q的所有对踵点对的差的集合，P-Q顶点数不超过P和Q的顶点和，若P和Q相交，则P-Q包含原点那么，本题就是求一个闽科夫斯基差的凸包，找出原点到凸包的最短距离……所以可以用旋转卡壳跑出所有对踵点对，然后求一下点-边的对踵点对中点到直线的距离就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;const double eps = 1e-10;const double pi = acos(-1);const int maxn = 5e4 + 5;inline int sgn(double x) &#123; if(x &lt; -eps) return -1; else if(x &gt; eps) return 1; else return 0;&#125;struct Point &#123; double x,y; Point(double _x = 0.0,double _y = 0.0): x(_x),y(_y) &#123;&#125; Point operator + (const Point &amp;b) const &#123; return Point(x + b.x,y + b.y); &#125; Point operator - (const Point &amp;b) const &#123; return Point(x - b.x,y - b.y); &#125; double operator * (const Point &amp;b) const &#123; //点乘 return (x * b.x + y * b.y); &#125; double operator ^ (const Point &amp;b) const &#123; //叉乘，判断b点的相对于该点位置关系 左正右负 return (x * b.y - y * b.x); &#125; Point operator * (double b) &#123; return Point(x * b,y * b); &#125; double norm() &#123; //求模 return sqrt(x * x + y * y); &#125;&#125;;struct Line &#123; Point s,e; Line() &#123;&#125; Line(Point _s,Point _e) &#123; s = _s; e = _e; &#125;&#125;;double dist(Point &amp;a,Point &amp;b) &#123; return (a - b).norm();&#125;Point Point_to_Line(Point p,Line l)&#123; double t = ((p - l.s) * (l.e - l.s)) / ((l.e - l.s) * (l.e - l.s)); return Point(l.s.x + (l.e.x - l.s.x) * t,l.s.y + (l.e.y - l.s.y) * t);&#125;//旋转卡壳double rot_solve(Point a[],Point b[],int n,int m) &#123; int fa,fb,i; Point u; for(fa = i = 0; i &lt; n; i++) &#123; if(a[i].y &lt; a[fa].y) fa = i; &#125; for(fb = i = 0; i &lt; m; i++) &#123; if(b[i].y &gt; b[fb].y) fb = i; &#125; a[n] = a[0]; b[m] = b[0]; double ans = 1e18; for(i = 0; i &lt; n; i++) &#123; while(sgn(((a[fa + 1] - a[fa]) ^ (b[fb + 1] - a[fa]))- ((a[fa + 1] - a[fa]) ^ (b[fb] - a[fa]))) == 1) fb = (fb + 1) % m; u = Point_to_Line(b[fb],Line(a[fa],a[fa + 1])); ans = min(ans,(b[fb] - u).norm()); fa = (fa + 1) % n; &#125; return ans;&#125;Point a[maxn],b[maxn];int main() &#123; int n,m,i; double x,y; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i = 0; i &lt; n; i++) &#123; scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y); a[i] = Point(x,y); &#125; for(i = 0; i &lt; m; i++) &#123; scanf(&quot;%lf%lf&quot;,&amp;x,&amp;y); b[i] = Point(x,y); &#125; double ans = min(rot_solve(a,b,n,m),rot_solve(b,a,m,n)); ans -= 60.0; if(sgn(ans) &lt;= 0) printf(&quot;0\n&quot;); else printf(&quot;%.12f\n&quot;,ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#418(Div. 2)_E]]></title>
      <url>%2F2017%2F06%2F08%2FCF-418(Div.%202)_E%2F</url>
      <content type="text"><![CDATA[我们按到点1的最短路径长度分层，因为满足$l_{i} \leq l_{i + 1}$，那么每一层的数一定是连续的。因为最短路径唯一，所以除1外的每个点都有且仅有一条边指向上一层，其它边要么指向同一层其它点，要么指向下一层。然后我们可以构造$DP$状态$f[i][j][k][l]$表示处理到第$i$个点，上一层有$j$条边尚未连接，这一层有$k$个点还有1条边位连接和有$l$个点还有2条边未连接。转移即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;const int inv2 = 500000004;int f[55][55][55][55];int d[55],inv[55];void add(int &amp;x,int y) &#123; x += y; if(x &gt;= MAX) x -= MAX;&#125;int mul(int x,int y) &#123; LL z = 1LL * x * y; return z - z / MAX * MAX;&#125;int main() &#123; int n,i,j,k,l; scanf(&quot;%d&quot;,&amp;n); for(i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;d[i]); inv[0] = 1; for(i = 1; i &lt;= n; i++) inv[i] = mul(inv[i - 1],inv2); if(d[1] == 2) f[2][d[1]][0][0] = inv2; else f[2][d[1]][0][0] = mul(333333336,inv2); for(i = 2; i &lt;= n; i++) &#123; for(j = 0; j &lt; i; j++) &#123; for(k = 0; k + j &lt; i; k++) &#123; if(f[i][0][j][k]) add(f[i][j + k * 2][0][0],mul(f[i][0][j][k],inv[k])); &#125; &#125; for(j = 1; j &lt;= n - i + 1; j++) &#123; for(k = 0; k &lt; i; k++) &#123; for(l = 0; l + k &lt; i; l++) &#123; if(f[i][j][k][l]) &#123; int x = mul(f[i][j][k][l],j); if(d[i] == 2) &#123; add(f[i + 1][j - 1][k + 1][l],x); if(k) add(f[i + 1][j - 1][k - 1][l],mul(x,k)); if(l) add(f[i + 1][j - 1][k + 1][l - 1],mul(x,l)); &#125; else &#123; add(f[i + 1][j - 1][k][l + 1],x); add(f[i + 1][j - 1][k][l],mul(x,k)); if(l) add(f[i + 1][j - 1][k + 2][l - 1],mul(x,l)); if(k &gt;= 2) add(f[i + 1][j - 1][k - 2][l],mul(mul(x,inv2),mul(k,k - 1))); if(l &gt;= 2) add(f[i + 1][j - 1][k + 2][l - 2],mul(mul(x,inv2),mul(l,l - 1))); if(k &amp;&amp; l) add(f[i + 1][j - 1][k][l - 1],mul(x,mul(k,l))); &#125; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\n&quot;,f[n + 1][0][0][0]); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZOJ2112]]></title>
      <url>%2F2017%2F06%2F05%2Fzoj2112%2F</url>
      <content type="text"><![CDATA[这道题就是带修改的求区间第k大非常经典的整体二分的题,因为满足查询的答案具有二分性，修改对答案的贡献相互独立，且可离线具体过程就是通过二分总体的答案，把最后答案小于mid的询问和值小于mid操作扔进一组，把其它的扔进另一组，使总体复杂度为$nlog^{2}n$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;const int maxn = 1e5 + 5;struct node &#123; int x,y,tp,id,k; node(int _x = 0,int _y = 0,int r = 0,int z = 0,int d = 0): x(_x),y(_y),tp(r),id(z),k(d) &#123;&#125;;&#125; f[maxn],q1[maxn],q2[maxn];int tot,num,n;int ans[maxn],a[maxn],g[maxn];int lowbit(int x) &#123; return x &amp; (-x);&#125;void add(int x,int d) &#123; while(x &lt;= n) &#123; g[x] += d; x += lowbit(x); &#125;&#125;int ff(int x) &#123; int s = 0; while(x &gt; 0) &#123; s += g[x]; x -= lowbit(x); &#125; return s;&#125;void solve(int ql,int qr,int l,int r) &#123; if(ql &gt; qr) return; if(l == r) &#123; for(int i = ql; i &lt;= qr; i++) &#123; if(f[i].tp == 3) ans[f[i].id] = l; &#125; return; &#125; int mid = (l + r) &gt;&gt; 1; int t1 = 0,t2 = 0; for(int i = ql; i &lt;= qr; i++) &#123; if(f[i].tp == 1) &#123; if(f[i].x &lt;= mid) &#123; add(f[i].id,1); q1[t1++] = f[i]; &#125; else q2[t2++] = f[i]; &#125; else if(f[i].tp == 2) &#123; if(f[i].x &lt;= mid) &#123; add(f[i].id,-1); q1[t1++] = f[i]; &#125; else q2[t2++] = f[i]; &#125; else &#123; int m = ff(f[i].y) - ff(f[i].x - 1); if(m &gt;= f[i].k) q1[t1++] = f[i]; else &#123; f[i].k -= m; q2[t2++] = f[i]; &#125; &#125; &#125; for(int i = ql; i &lt;= qr; i++) &#123; if(f[i].tp == 1) &#123; if(f[i].x &lt;= mid) add(f[i].id,-1); &#125; else if(f[i].tp == 2) &#123; if(f[i].x &lt;= mid) add(f[i].id,1); &#125; &#125; memcpy(f + ql, q1, t1 * sizeof(node)); memcpy(f + ql + t1, q2, t2 * sizeof(node)); solve(ql,ql + t1 - 1,l,mid); solve(ql + t1,qr,mid + 1,r);&#125;int main() &#123; int t,m,i,x,l,r; char e; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); tot = num = 0; for(i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); f[++tot] = node(a[i],0,1,i,0); &#125; for(i = 0; i &lt; m; i++) &#123; scanf(&quot; %c&quot;,&amp;e); //cout&lt;&lt;i&lt;&lt;endl; if(e == &apos;Q&apos;) &#123; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); f[++tot] = node(l,r,3,++num,x); &#125; else &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;x); f[++tot] = node(a[l],0,2,l,0); f[++tot] = node(x,0,1,l,0); a[l] = x; &#125; &#125; //cout&lt;&lt;&quot;----&quot;&lt;&lt;endl; solve(1,tot,1,1000000000); for(i = 1; i &lt;= num; i++) printf(&quot;%d\n&quot;,ans[i]); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[敲黑板~]]></title>
      <url>%2F2017%2F06%2F04%2Fplan2%2F</url>
      <content type="text"><![CDATA[需要疯狂刷题了……然后写题解、、]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM知识点]]></title>
      <url>%2F2017%2F03%2F15%2Fplan%2F</url>
      <content type="text"><![CDATA[啦啦啦~~2017.06.15更新 [ ] 基础算法 [x] 模拟 [x] 枚举 [x] 贪心 [x] 高精度 [x] 排序 [x] 递推 [x] 递归 [x] 二分 [ ] 01分数规划 [ ] 整体二分 [x] 倍增 [x] 位运算 [x] 离散化 [ ] 分块 [x] 前缀和 [x] 启发式合并 [x] 分治 [ ] 随机化 [x] 莫队算法 [ ] 数据结构 [x] 队列 [x] 栈 [x] 堆 [x] 链表 [x] 哈希表 [x] 树状数组 [x] 线段树 [ ] 平衡树 [ ] Spaly [ ] Treap [ ] SBT [x] 主席树 [ ] KD树 [ ] 树套树 [x] STL [ ] 图论(有待重新学习) [ ] 搜索 [x] DFS [x] BFS [x] 记忆化 [ ] A* [ ] IDA* [ ] 模拟退火 [ ] 爬山算法 [ ] 蚁群算法？ [x] 并查集 [x] 欧拉图 [x] 拓扑排序 [ ] 最短路 [x] SPFA [x] Dijkstra [x] Floyd [ ] k短路 [x] 差分约束 [x] Tarjan [x] 强连通 [x] 双连通 [x] LCA [x] 2-SAT [ ] 二分图 [ ] 最大匹配 [ ] 最大权匹配 [ ] 网络流 [ ] 最大流最小割 [ ] 费用流 [ ] 有界流 [ ] 树 [x] 最小生成树 [x] DFS序 [x] 重心 [x] 直径 [x] LCA [x] 树分治 [ ] 树同构 [ ] 树链剖分 [ ] LCT [ ] 基环树 [ ] 带花树(非二分图最大匹配) [x] 最小树形图 [ ] 字符串 [x] KMP [x] 最小表示法 [x] AC自动机 [x] Trie树 [x] 后缀数组 [x] 后缀自动机 [x] Manacher [x] 回文自动机 [ ] DP [x] 背包 [x] 区间DP [x] 树形DP [x] 数位DP [x] 期望DP [x] 记忆化搜索DP [x] 状压DP [ ] 轮廓线DP [x] 四边形不等式优化 [x] 斜率优化 [ ] 几何 [x] 叉积和点积 [x] 凸包 [x] 旋转卡壳 [x] 半平面交 [x] Pick定理 [x] 辛普森积分 [x] 三角剖分 [ ] 随机增量 [ ] 反演变换 [ ] 数学 [ ] 博弈 [x] SG函数 [ ] A-Beta剪枝 [ ] 极大极小搜索 [x] 线性筛 [x] 素数测试 [x] 欧拉函数 [x] 快速幂 [x] GCD [x] EXGCD [x] 乘法逆元 [x] CRT [x] 容斥 [x] 矩阵 [x] Poyla定理 [x] 组合数 [ ] BSGS [ ] 单纯形 [x] 拉格朗日插值法 [x] FFT &amp; NTT [x] 多项式求逆&amp;开方 [x] 反演]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[miss and miss]]></title>
      <url>%2F2017%2F03%2F15%2Fyou%2F</url>
      <content type="text"><![CDATA[和有爱的人在一起，每一段恋情，都能成全一个更好的彼此 风信子的风 春日游，杏花吹满头。陌上谁家年少足风流？总有一个人，总有一个时刻，会让你望她的着聊天窗口发呆半天，反反复复写下了一句又一句想说的话，最后又一个字一个字的删掉……即使写下了，手指也会停留在发送键上久久不敢按下……那是一道比做高考语文题还需要反复琢磨的题……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[maybe]]></title>
      <url>%2F2017%2F03%2F04%2Fmiss%2F</url>
      <content type="text"><![CDATA[和有爱的人在一起，每一段恋情，都能成全一个更好的彼此有些东西，放下了，对大家都好 我们都要含蓄一点~ 002582是好想你今晚月色真美是我爱你ρ=a(1+cosθ)是心形线下图是I LOVE U的函数表达式 不恨此花飞尽，恨西园，落红难缀、去年今日此门中，人面桃花相映红。人面不知何处在，桃花依旧笑春风。 山有木兮木有枝,心悦君兮君不知愿岁月可回首，且以深情共白头谁拿流年乱了浮生，又借浮生乱了红尘。此生若能得幸福安稳，谁又愿颠沛流离 心若没有栖息的地方,到哪里都是流浪]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#388(Div. 2)_E]]></title>
      <url>%2F2016%2F12%2F20%2FCF-388(Div.%202)_E%2F</url>
      <content type="text"><![CDATA[题目传送门题意略、首先，我们可以发现，每对数对答案的贡献是独立的，于是，我们先考虑第$i$个数和第$j$个数对答案的贡献$P\left ( i,j \right )$(下标从$1$开始)：可以，算出，包含$i$和$j$的区间个数为$i\left ( n - j + 1 \right )$个，对于每个区间，我们可以发现第$i$个数在第$j$个数前面的概率和第$i$个数在第$j$个数后面的概率是相同的，都是$\frac{1}{2}$(原因想想就知道了)。当选择的区间没有同时包含$i$和$j$时，其贡献为$\left[ a_i &gt; a_j \right]$所以，我们就能得到$P\left ( i,j \right )= \left ( 1 - \frac{2i\left ( n - j + 1 \right )}{n\left ( n + 1 \right )}\right )\left [ a_{i}&gt; a_{j} \right ] + \frac{i\left ( n - j + 1 \right )}{n\left ( n + 1 \right )}$所以，最后的答案就是$$\sum_{i = 1}^{n -1}\sum_{j = i + 1}^{n}\left ( 1 - \frac{2i\left ( n - j + 1 \right )}{n\left ( n + 1 \right )}\right )\left [ a_{i}&gt; a_{j} \right ] + \frac{i\left ( n - j + 1 \right )}{n\left ( n + 1 \right )}$$当然，我们肯定不能暴力枚举每一对$i$和$j$，但是，我们把上式变形一下，然后化简，就可以得到$$\sum_{i = 1}^{n - 1}\left ( \frac{i\left ( n - i \right )\left ( n - i + 1 \right )}{2n\left ( n + 1 \right )} + \sum_{j = i + 1}^{n}\left [ a_{i} &gt; a_{j} \right ] + \frac{2i}{n\left ( n + 1 \right )} \sum_{j = i + 1}^{n}\left ( n - j + 1 \right )\left [ a_{i}&gt; a_{j} \right ] \right )$$右边的两个和式一个就是求逆序数个数，另一个就是求逆序数的下标和，显然都可以在$nlogn$的时间维护出来所以……就做出来啦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;typedef pair&lt;LL,LL&gt; P;const int maxn = 100005;LL sum[maxn * 4];int num[maxn * 4];int a[maxn],n;void add(int t,int l,int r,int x)&#123; if(l == r) &#123; num[t]++; sum[t] += n - x + 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if(a[x] &lt;= mid) add(t&lt;&lt;1,l,mid,x); else add(t&lt;&lt;1|1,mid + 1,r,x); num[t]++; sum[t] += n - x + 1;&#125;P query(int t,int l,int r,int x)&#123; if(r &lt;= a[x]) return P(sum[t],num[t]); int mid = (l + r) &gt;&gt; 1; if(a[x] &lt;= mid) return query(t&lt;&lt;1,l,mid,x); else &#123; P u,v; u = query(t&lt;&lt;1,l,mid,x); v = query(t&lt;&lt;1|1,mid + 1,r,x); return P(u.first + v.first,u.second + v.second); &#125;&#125;int main()&#123; int i; P u; LL f = 0,e = 0; long double ans; scanf("%d",&amp;n); for(i = 1;i &lt;= n; i++) scanf("%d",&amp;a[i]); add(1,1,n,n); for(i = n - 1;i &gt; 0; i--) &#123; e += 1LL * (n - i) * (n - i + 1) / 2 * i; u = query(1,1,n,i); e -= u.first * i * 2LL; f += u.second; add(1,1,n,i); &#125; ans = 1.0 * e / (1LL * n * (n + 1)) + f; printf("%.10f\n",(double)ans); return 0;&#125; 后记：使用下标要加斜杠，不然显示不出来大括号……也有问题，还是别用了结论：GFM并不是标准的markdown]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CF_#384(Div. 2)_E]]></title>
      <url>%2F2016%2F12%2F15%2FCF-384(Div.%202)_E%2F</url>
      <content type="text"><![CDATA[题目传送门题意就是给你一个只含数字1~8的序列，让你找到一个最长的子序列，这个子序列满足1~8的个数相差不超过1，相同数字必须连续出现。首先，我们假设选择的同一数字最少个数为t，那么最多个数就为t+1，然后我们可以枚举这个t是多少，或者二分这个t。然后我们考虑对于一个给定的t，怎么求答案，我们考虑用一个数组f[i][j]表示计算了前i个数状态为j的最大个数，j表示1~8中哪些数字已经选了，因为题目要求相同数字必须连续，所以每种数字只用选一次，所以可以用DP很好的实现。然后我们考虑转移，定义b[k]表示第k个数字从i+1开始的第t次出现的最小位置，b[k]表示第k个数字从i+1开始的第t+1次出现的最小位置，然后就有转移方程12updata(f[b[k]][j | (1 &lt;&lt; k)],f[i][j] + t);updata(f[c[k]][j | (1 &lt;&lt; k)],f[i][j] + t + 1); 而b[k]和c[k]我们可以在线性时间贪心出来，具体实现看代码、1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;int a[1205],n,ans = 0;int f[1205][1&lt;&lt;8],b[9],c[9];void updata(int &amp;x,int y)&#123; if(x == -1) x = y; else x = max(x,y);&#125;bool check(int t)&#123; memset(f,-1,sizeof(f)); int i,j,k; for(i = 0; i &lt; 8; i++) &#123; j = 0; b[i] = 0; while(j &lt; t &amp;&amp; b[i] &lt;= n) &#123; b[i]++; if(a[b[i]] == i) j++; &#125; c[i] = b[i]; while(j &lt;= t &amp;&amp; c[i] &lt;= n) &#123; c[i]++; if(a[c[i]] == i) j++; &#125; &#125; for(k = 0; k &lt; 8; k++) &#123; updata(f[b[k]][(1 &lt;&lt; k)],t); updata(f[c[k]][(1 &lt;&lt; k)],t + 1); &#125; for(i = 1; i &lt;= n; i++) &#123; j = a[i]; b[j] = c[j]; c[j]++; while(a[c[j]] != j &amp;&amp; c[j] &lt;= n) c[j]++; for(j = 0; j &lt; (1 &lt;&lt; 8); j++) &#123; if(f[i][j] != -1) &#123; for(k = 0; k &lt; 8; k++) &#123; if(!(j &amp; (1 &lt;&lt; k))) &#123; updata(f[b[k]][j | (1 &lt;&lt; k)],f[i][j] + t); updata(f[c[k]][j | (1 &lt;&lt; k)],f[i][j] + t + 1); &#125; &#125; &#125; &#125; &#125; i = -1; for(j = 1; j &lt;= n; j++) i = max(i,f[j][(1 &lt;&lt; 8) - 1]); ans = max(ans,i); return (i &gt;= 0);&#125;int main()&#123; int i,l,r,mid; int p[10]; memset(p,0,sizeof(p)); scanf("%d",&amp;n); for(i = 1; i &lt;= n; i++) &#123; scanf("%d",&amp;a[i]); a[i]--; p[a[i]] = 1; &#125; for(i = 0; i &lt; 8; i++) ans += p[i]; l = 1; r = n / 8; while(l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[无题]]></title>
      <url>%2F2016%2F12%2F10%2Fluanluande%2F</url>
      <content type="text"><![CDATA[心似繁星，情如春水每天的脑子都是那么的乱，那么，我为什么不把那些碎片化的思绪串接一下呢、 思时间呀时间，你去哪里了呀……虽然才大二，但是感觉实习已经离我不远了……所有害怕面对的，终会去面对，所有不想结束的，终会去结束、 弃比赛雪崩，考试忘记……好想好想去睡那么一觉……感觉需要颓废一天了……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[临行、前夕]]></title>
      <url>%2F2016%2F12%2F08%2Fwho_know%2F</url>
      <content type="text"><![CDATA[明天就要去上海参加EC-final了，但是此文与此无关，迷迷迷 昨日，未识 成都的天气，在经历了几天的雾霾，现在似乎有了一些些好转。不过温度，似乎越来越冷了呢。 不知几时，地上的银杏落叶已经堆满，冬初的凄凉，在那泛黄的世界中被尽数诉说。行走在其间，总有着一种时间的沧桑感。对呀，已经又是一年了，这一学期也快要结束了。时间过得总是那么的快，感觉我都来不及驻足观望一番，就都过去了，只能去匆匆迎接新的时光。 听闻以前的我很高冷，其实仔细想想，现在的我，似乎真的与以前不同了呢。是自我保护意识太强了吗，或是无话可说，或是其它什么的，以前的我话似乎比现在少很多。虽然，我也不认为我现在话就很多了。应该，对熟一点人，我的话才会多那么一些吧。不过，有时候想想，我为什么一定要话多呢，我只需要做那个我自己认为可以的我就好了。酒逢知己千杯少，话不投机半句多 有时候，也会想让自己作出改变，于是有时候就会决定自己要把这个改掉，可能结果不尽如人意。有时候，我想让自己去为一个人改变，或许自我感觉这样的成功率要高一些吧。的确，这样确实让我改变了很多，但是，有时候又觉得，那样似乎又不是我想要的我了。 过去的都过去了，现在的我和过去的我并没有什么不好的，以后的我也许和现在的我会有很多巨大的差异，但是又有什么实质的不同吗？ 我该做什么 我该做什么呢，这个问题感觉我并不清楚吧。 有时候，觉得学习课本是必须的，但是，又不是很想学，总是由于某些客观的因素被动的学习着某些知识，终是考完就忘光的节奏。 有时候呢，觉得我需要学习更多计算机相关的知识，但是又发现食之无味，兴趣大减，倒不如学习ACM相关的一些知识。 也有时候，想去打游戏，但是，打着打着，还是觉得无趣，或许一个人的游戏终不算是游戏吧。 其实呢，现在也还是不错的，每天学一学ACM的知识，也挂一挂游戏，虽然对专业的教的知识已经丧失了以前的兴趣，但是也还是会去看一看。 就这样吧，这样就可以了。 卡题了，码不动了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CDOJ 811 GCD]]></title>
      <url>%2F2016%2F12%2F08%2FCDOJ%20811%20GCD%2F</url>
      <content type="text"><![CDATA[建议先看这篇文章.很显然，所求的式子可以化为$$\sum_{i=1}^{n}i^{k}\left(2\phi\left(\frac{n}{i}\right)-1\right)$$其中，$\phi\left(\frac{n}{i}\right)$是欧拉函数的前缀和，这个可以用刚刚提到的那篇文章的方法在$o\left ( n^{\frac{2}{3}} \right )$复杂度求解。而左边那个$k$次方前缀和可以直接百度求值，或者暴力插值求解。反正就这样搞搞就行了，智障少年写不动题解了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//created by missever#include&lt;bits/stdc++.h&gt;#define MAX 1000000007using namespace std;typedef long long LL;const int maxn = 1e7+5;const int rev = (MAX + 1) &gt;&gt; 1;bool flag[maxn];int phi[maxn],pri[maxn];int cnt = 0,k;LL sum[maxn];LL a[8],b[8],c[8];map&lt;LL,LL&gt; p;void Get_phi()&#123; phi[1] = 1; sum[1] = 1; for(int i = 2; i &lt; maxn; i++) &#123; if(!flag[i]) &#123; pri[cnt++] = i; phi[i] = i - 1; &#125; for(int j = 0; j &lt; cnt; j++) &#123; if(i * pri[j] &gt; maxn) break; flag[i * pri[j]] = true; if(i % pri[j] == 0) &#123; phi[i * pri[j]] = pri[j] * phi[i]; break; &#125; else phi[i * pri[j]] = (pri[j] - 1) * phi[i]; &#125; sum[i] = (sum[i - 1] + phi[i]) % MAX; &#125;&#125;LL Get_sumpri(LL n)&#123; if(n &lt; maxn) return sum[n]; if(p.find(n) != p.end()) return p[n]; LL i,j; LL s = n % MAX * ((n + 1) % MAX) % MAX * rev % MAX; for(i = 2; i &lt;= n; i = j + 1) &#123; j = n / (n / i); s = (s - (j - i + 1) % MAX * Get_sumpri(n / i) % MAX) % MAX; &#125; s = (s + MAX) % MAX; p[n] = s; return s;&#125;void extend_Euclid(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(b == 0) &#123; x = 1; y = 0; return; &#125; extend_Euclid(b, a % b, x, y); LL tmp = x; x = y; y = tmp - (a / b) * y;&#125;LL Inv(LL a, LL b)&#123; LL x, y; extend_Euclid(a, b, x, y); return (x % b + b) % b;&#125;LL Get_kpow(LL n)&#123; if(n &lt;= k + 1) return a[n]; LL i,j; LL s = 0,f; for(i = 0;i &lt;= k + 1; i++) &#123; f = 1; for(j = 0;j &lt;= k + 1; j++) &#123; if(j != i) f = (n - j) % MAX * f % MAX; &#125; s = (s + f * c[i] % MAX) % MAX; &#125; return (s + MAX) % MAX;&#125;LL Get_ans(LL n)&#123; LL i,j; LL s = 0,f = 0,g; for(i = 1; i &lt;= n; i = j + 1) &#123; j = n / (n / i); g = Get_kpow(j); s = (s + (Get_sumpri(n / i) * 2LL - 1LL) % MAX * ((g - f + MAX) % MAX) % MAX) % MAX; f = g; &#125; return (s + MAX) % MAX;&#125;int main()&#123; Get_phi(); LL n; int i,j; scanf("%lld",&amp;n); scanf("%d",&amp;k); b[0] = 1; for(i = 1;i &lt;= k + 1; i++) &#123; a[i] = i; for(j = 1;j &lt; k; j++) a[i] = a[i] * i % MAX; a[i] = (a[i] + a[i - 1]) % MAX; b[i] = b[i - 1] * i % MAX; &#125; for(i = 1;i &lt;= k + 1; i++) &#123; c[i] = a[i] * Inv(b[i] * b[k + 1 - i] % MAX,MAX) % MAX; if((k + 1 - i) &amp; 1) c[i] = -c[i]; &#125; printf("%lld\n",Get_ans(n)); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初记、]]></title>
      <url>%2F2016%2F12%2F07%2Fthe-first-article%2F</url>
      <content type="text"><![CDATA[终于把博客搭起来了，虽然还有很多地方没有完善……先mark一下吧、、]]></content>
    </entry>

    
  
  
</search>
