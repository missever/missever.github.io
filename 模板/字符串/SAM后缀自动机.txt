const int maxn = 2e5 + 5;
const int maxm = 26;

struct SAM
{
    // 要开2倍字符串长度
    // 每次插入的是以i结点结尾的前缀
    // val 以i结尾的子串个数,等价于到根结点距离，也是i表示的最长的字符串的长度
    // i与pr[i] 成父子关系，父亲是儿子的一个后缀
    //添加第i个字符时，自动机里新增了diff = val[np] - val[pre[np]] 个与原先不同的子串，它们分别是 s[0......i]，s[1......i]，……，s[diff-1......i]
    // pr[i] 不一定比 i 小
    int tr[maxn][maxm],pr[maxn],val[maxn],tot,last;
    int len[maxn],sub[maxn];
    void init()
    {
        last = tot = 0;
        memset(tr[0],-1,sizeof(tr[0]));
        pr[0] = -1;
        val[0] = 0;
    }
    void ins(int c)
    {
        int np = ++tot,p = last;
        val[np] = val[p] + 1;
        memset(tr[np], -1, sizeof(tr[np]));
        sub[np] = 1;
        while(~p && tr[p][c] == -1) tr[p][c] = np, p = pr[p];
        if(p == -1) pr[np] = 0;
        else{
            int q = tr[p][c];
            if(val[q] != val[p] + 1){
                int nq = ++tot;
                memcpy(tr[nq], tr[q], sizeof(tr[q]));
                val[nq] = val[p] + 1;
                pr[nq] = pr[q];
                pr[q] = pr[np] = nq;
                while(~p && tr[p][c] == q) tr[p][c] = nq, p = pr[p];
            }
            else pr[np] = q;
        }
        last = np;
        //return val[np] - val[pr[np]];
    }
    queue<int> qq;
    void toposort()
    {
        for(int i = 1;i <= tot; i++) len[pr[i]]++;
        for(int i = 0;i <= tot; i++)
        {
            if(!len[i]) qq.push(i);
        }
        while(!qq.empty())
        {
            int u = qq.front();
            qq.pop();
            sub[pr[u]] += sub[u];
            len[pr[u]]--;
            if(!len[pr[u]]) qq.push(pr[u]);
        }
    }
    int count()
    {
        int sum = 0;
        for(int i = 0;i <= tot; i++) sum += val[i] - val[pr[i]];//i结点新增子串数
        return sum;
    }
    //公共串匹配
    int ff(char s[]){
        int sz = strlen(s),u = 0,tmp = 0,c,i,res = 0;
        for(i = 0; i < sz; i++){
            c = s[i] - 'a';
            if(~tr[u][c]) tmp++,u = tr[u][c];
            else{
                while(~u && tr[u][c] == -1) u = pr[u];
                if(~u) tmp = val[u] + 1,u = tr[u][c];
                else tmp = 0,u = 0;
            }
            res = max(res,tmp);
        }
        return res;
    }
} SS;