const int MAXN = 100005;
const int N = 26;

struct Palindromic_Tree
{
    int next[MAXN][N];//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成
    int fail[MAXN];//fail指针，失配后跳转到fail指针指向的节点
    int cnt[MAXN];//节点i表示的本质不同的串的个数,要跑一遍count函数才行
    int num[MAXN];//以节点i结尾的回文串个数
    int len[MAXN];//len[i]表示节点i表示的回文串的长度
    int S[MAXN];//存放添加的字符
    int last;//指向上一个字符所在的节点，方便下一次add
    // 把以当前点结尾的相邻两个回文串的长度作差,把相邻的相同差值的归为一段,可以证明最多只有log段
    // diff表示差值,slink表示下一个不同差值的点 fp表示该点dp取最优值的前驱位置
    int diff[maxn], slink[maxn], fp[maxn];
    int n;//字符数组指针
    int p;//节点指针

    int newnode(int l) //新建节点
    {
        for(int i = 0; i < N; ++i) next[p][i] = 0;
        cnt[p] = 0;
        num[p] = 0;
        len[p] = l;
        return p++;
    }
    void init() //初始化
    {
        p = 0;
        newnode(0);
        newnode(-1);
        last = 0;
        n = 0;
        S[n] = -1;//开头放一个字符集中没有的字符，减少特判
        fail[0] = 1;
    }
    int get_fail(int x) //和KMP一样，失配后找一个尽量最长的
    {
        while(S[n - len[x] - 1] != S[n]) x = fail[x];
        return x;
    }
    void add(int c)
    {
        c -= 'a';
        S[++n] = c;
        int cur = get_fail(last);//通过上一个回文串找这个回文串的匹配位置
        if ( !next[cur][c]) //如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串
        {
            int now = newnode(len[cur] + 2) ;//新建节点
            fail[now] = next[get_fail(fail[cur])][c];//和AC自动机一样建立fail指针，以便失配后跳转
            next[cur][c] = now;
            num[now] = num[fail[now]] + 1;
            diff[now] = len[now] - len[fail[now]];
            slink[now] = (diff[now] == diff[fail[now]] ? slink[fail[now]] : fail[now]);
        }
        last = next[cur][c];
        cnt[last]++;
        return last;
    }
    // 回文分解,记得初始化dp
    void solve(int dp[], int pre[], char s[], int n) {
        int i, j;
        init();
        dp[0] = 0;
        fp[0] = 1;
        // 字符串范围在1-n
        for(i = 1; i <= n; i++) {
            // 以差值不同分为不同的部分
            for(j = add(s[i]); j; j = slink[j]) {
                // 这个部分的第一个下标
                fp[j] = i - (len[slink[j]] + diff[j]);
                // 差值相同表示属于同一个部分
                // 因为前面把fail[j]之后的点的最优值处理到了fail[j],所以只需要处理j和fail[j]即可得到这个部分的最优值
                // 并把最优值放到fp[j]里
                if(diff[fail[j]] == diff[j] && dp[fp[j]] > dp[fp[fail[j]]]) fp[j] = fp[fail[j]];
                if(dp[i] > dp[fp[j]] + 1) {
                    dp[i] = dp[fp[j]] + 1;
                    pre[i] = fp[j]; // 方案记录
                }
            }
        }
    }
    void count()
    {
        for(int i = p - 1;i >= 0; --i) cnt[fail[i]] += cnt[i];
        //父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！
    }
};