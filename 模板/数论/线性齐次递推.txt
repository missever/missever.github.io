//求第n项,a[]中记录0~m-1项,c[]记录转移式
//f(n)=f(n-1)c(m-1)+f(n-2)c(m-2)+...+f(n-m)c(0)
int Solve(int n, int m, int a[], int c[]) {
    int v[maxn] = {1}, u[maxn * 2], an = 0;
    int W = !!n, x, b;
    int i, j, t;
    for(x = n; x > 1; x >>= 1) W <<= 1;
    for(x = 0; W; W >>= 1, x <<= 1) {
        memset(u, 0, sizeof(u));
        if(b = !!(n & W)) x |= 1;
        if(x < m) u[x] = 1;
        else {
            for(i = 0; i < m; i++) {
                for(j = 0, t = i + b; j < m; j++, t++) u[t] = add(u[t], mul(v[i], v[j]));
            }
            for(i = m * 2 - 1; i >= m; i--) {
                for(j = 0, t = i - m; j < m; j++, t++) u[t] = add(u[t], mul(u[i], c[j]));
            }
        }
        copy(u, u + m, v);
    }
    for(i = 0; i < m; i++)an = add(an, mul(v[i], a[i]));
    return an;
}

//输入序列前n项 a 返回 系数序列c和长度
int BM(int n, int a[], int c[]) {
    static int b[maxn], ct[maxn];
    b[0] = c[0] = 1;
    int L = 0, m = 1, cb = 1, szb = 1, szc = 1, d, i, j;
    for(i = 0; i < n; i++) {
        for(j = d = 0; j <= L; j++) d = add(d, mul(c[j], a[i - j]));
        if(d == 0) ++m;
        else if(2 * L <= i) {
            memcpy(ct, c, sizeof(int) * szc);
            int tmp = szc, res = mod - mul(d, powt(cb, mod - 2));
            while(szc < szb + m) c[szc++] = 0;
            for(j = 0; j < szb; j++) c[j + m] = add(c[j + m], mul(res, b[j]));
            memcpy(b, ct, sizeof(int) * tmp);
            szb = tmp;
            L = i + 1 - L;
            cb = d;
            m = 1;
        } else {
            d = mod - mul(d, powt(cb, mod - 2));
            while(szc < szb + m) c[szc++] = 0;
            for(j = 0; j < szb; j++) c[j + m] = add(c[j + m], mul(d, b[j]));
            ++m;
        }
    }
    szc--;
    for(i = 0;i < szc; i++) c[i] = add(0, mod - c[i + 1]);
    reverse(c, c + szc);
    return szc;
}