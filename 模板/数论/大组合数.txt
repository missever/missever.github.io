//lucas可推广到多项式系数n!/(a!b!c!……)  a+b+c+……=n


long long m,q[100010];//模数为m
long long pow(long long a,long long b)
{
    long long r=1,base=a;
    while(b!=0)
    {
        if(b&1) r=r*base%m;
        base=base*base%m;
        b>>=1;
    }
    return r;
}

long long gcd(long long a,long long b)
{
    if(b==0) return a;
    else return gcd(b,a%b);
}

long long cc(long long a,long long b)
{
    if(a<b) return 0;
    return q[a]*pow(q[b]*q[a-b]%m,m-2)%m;
}

long long Lucas(long long a,long long b)//输入a为底的组合数
{
    if(b==0)    return 1;
    return (cc(a%m,b%m)*Lucas(a/m,b/m))%m;
}



//任意模数取模
LL powt(LL a,LL b,LL mod)
{
    LL r = 1;
    while(b)
    {
        if(b & 1) r = r * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return r;
}

void extend_Euclid(LL a, LL b, LL &x, LL &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return;
    }
    extend_Euclid(b, a % b, x, y);
    LL tmp = x;
    x = y;
    y = tmp - (a / b) * y;
}

LL Inv(LL a, LL b)
{
    LL x, y;
    extend_Euclid(a, b, x, y);
    return (x % b + b) % b;
}

LL CRT(LL a[],LL m[],int n,LL M)
{
    LL ans = 0;
    for(int i = 0; i < n; i++)
    {
        LL x, y;
        LL Mi = M / m[i];
        extend_Euclid(Mi, m[i], x, y);
        ans = (ans + Mi * x * a[i]) % M;
    }
    if(ans < 0) ans += M;
    return ans;
}

LL c(LL n,LL p,LL mod)
{
    if(n == 0) return 1;
    LL i,s = 1,d = 1,r = n % mod;
    for(i = 2;i < mod; i++)
    {
        if(i % p) d = d * i % mod;
        if(i == r) s = d;
    }
    return s * powt(d,n / mod,mod) % mod * c(n / p,p,mod) % mod;
}

LL cal(LL n,LL m,LL p,LL k,LL mod)
{
    LL x,s,t = 0;
    x = n;
    while(x) x /= p,t += x;
    x = m;
    while(x) x /= p,t -= x;
    x = n - m;
    while(x) x /= p,t -= x;
    if(t >= k) return 0;
    else s = powt(p,t,mod);
    s = s * c(n,p,mod) % mod * Inv(c(m,p,mod),mod) % mod * Inv(c(n - m,p,mod),mod) % mod;
    return s;
}

LL exlucas(LL n,LL m,LL mod)
{
    if(m > n) return 0;
    LL i,t,x,k = 0;
    LL a[105],b[105];
    for(x = mod,i = 2;i * i <= x; i++)
    {
        if(x % i == 0)
        {
            t = 0;
            b[k] = x;
            while(x % i == 0)
            {
                t++;
                x /= i;
            }
            b[k] /= x;
            a[k] = cal(n,m,i,t,b[k]);
            k++;
        }
    }
    if(x > 1)
    {
        b[k] = x;
        a[k] = cal(n,m,b[k],1,b[k]);
        k++;
    }
    return CRT(a,b,k,mod);
}
