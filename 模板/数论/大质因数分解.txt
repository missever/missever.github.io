LL add(LL x,LL y,LL m) {
    x += y;
    if(x >= m) x -= m;
    return x;
}

LL mul(LL a,LL b,LL m) {
    LL r = (a * b - (LL)(((long double)a * b) / m) * m);
    return add(r - r / m * m,m,m);
}

LL powt(LL a,LL b,LL m) {
    LL r = 1;
    while(b) {
        if(b & 1) r = mul(r,a,m);
        a = mul(a,a,m);
        b >>= 1;
    }
    return r;
}

bool flag[maxn];
int pri[maxn],cnt = 0;
void GetPrime() {
    for (int i = 2; i < maxn; ++i) {
        if (!flag[i]) pri[cnt++] = i;
        for (int j = 0; j < cnt && pri[j] * i < maxn; ++j) {
            flag[pri[j] * i] = 1;
            if (i % pri[j] == 0) break;
        }
    }
}

LL Rand(LL n) {
    return (((LL)rand()<<31)|rand())%(n-1)+1;
}

bool test(LL n,LL a,LL d) {
    if(n == 2) return true;
    if(n == a) return true;
    if(!(n & 1)) return false;
    while(!(d & 1)) d >>= 1;
    LL t = powt(a,d,n);
    while(d != n - 1 && t != n - 1 && t != 1) {
        t = mul(t,t,n);
        d <<= 1;
    }
    return t == n - 1 || (d & 1) == 1;
}

bool isprime(LL n) {
    for(int i = 0; i < 6; i++) {
        if(!test(n,pri[Rand(cnt) - 1],n - 1)) return false;
    }
    return true;
}

LL Pollard_rho(LL n,LL c) {
    LL i = 1,k = 2;
    LL x = Rand(n);
    LL y = x;
    while(true) {
        x = add(mul(x,x,n),c,n);
        LL d = __gcd(abs(y - x),n);
        if(d != 1 && d != n) return d;
        if(x == y) return n;
        if(++i == k) y = x,k <<= 1;
    }
}

void findfac(LL n,map<LL,int> &fac) {
    if(n <= 1) return;
    if(isprime(n)) {
        fac[n]++;
        return;
    }
    LL p = n;
    while(p >= n) p = Pollard_rho(p,Rand(n));
    findfac(p,fac);
    findfac(n / p,fac);
}

map<LL,int> fac;

int main() {
    srand(772002);
    GetPrime();
    findfac(n,fac);
    return 0;
}
