若二元运算中带有bit位限制，如子集卷积中为i ^ j = k[bit(i) + bit(j) = bit(k)] //bit(i)为i中1的个数
可以增加一维，令f[bit(i)][i] = a[i]，g[bit(i)][i] = b[i],对f[i],g[i]分别进行fwt，然后得h[k][i] = f[x][i] * g[k - x][i]，再对h[i]进行ufwt，h[bit(i)][i]即是答案

void FWT(int a[],int n)    
{    
    for(int d = 1;d < n;d <<= 1)    
        for(int m = d << 1,i = 0;i < n;i += m)    
            for(int j = 0;j < d; j++)    
            {    
                int x = a[i + j],y = a[i + j + d];    
                a[i + j] = (x + y) % mod,a[i + j + d]=(x - y + mod) % mod;    
                //xor:a[i+j]=x+y,a[i+j+d]=(x-y+mod)%mod;    
                //and:a[i+j]=x+y;    
                //or:a[i+j+d]=x+y;    
            }    
}    
    
void UFWT(int a[],int n)    
{    
    for(int d = 1;d < n;d <<= 1)    
        for(int m = d << 1,i = 0;i < n;i += m)    
            for(int j = 0;j < d; j++)    
            {    
                int x = a[i + j],y = a[i + j + d];    
                a[i + j] = 1LL * (x + y) * rev % mod,a[i + j + d] = (1LL * (x - y) * rev % mod + mod) % mod;    
                //xor:a[i+j]=(x+y)/2,a[i+j+d]=(x-y)/2;    
                //and:a[i+j]=x-y;    
                //or:a[i+j+d]=y-x;    
            }    
}    
void solve(int a[],int b[],int n)    
{    
    FWT(a,n);    
    FWT(b,n);    
    for(int i = 0;i < n; i++) a[i] = 1LL * a[i] * b[i] % mod;    
    UFWT(a,n);    
}    