// 过不了uoj179的变态hack数据……不过其他题水过似乎没什么问题
const int maxn = 1050;
const double eps = 1e-8;
struct Simplex {
    int n, m;
    int idx[maxn], idy[maxn];
    double a[maxn][maxn], ans[maxn];
    //复杂度大概 nm^2 ? 可能再乘一个大常数
    //n个变量 m条约束
    //a[i][j]:i表第几条约束 j表第几个元素
    //a[0][i] -> ci 目标函数中第i个元素系数
    //a[i][0] -> bi 第i条约束中的常数,sigma(Aij*xi) <= bi
    //a[i][j] -> Aij 第i条约束中第j个元素的系数
    //求最大化 sigma(ci*xi),i∈N
    //约束 xj=bj-sigma(aji*xi) ,j∈B, xj>=0
    void init(int _n, int _m) {
        n = _n;
        m =  _m;
        for(int i = 0; i <= n; i++) idx[i] = i;
        for(int i = 1; i <= m; i++) idy[i] = i + n;
    }
    void pivot(int u, int v) {
        swap(idx[v], idy[u]);
        double t = a[u][v];
        a[u][v] = 1.0;
        for(int i = 0; i <= n; i++) a[u][i] /= t;
        for(int i = 0; i <= m; i++) {
            if(i == u || fabs(a[i][v]) < eps) continue;
            t = a[i][v];
            a[i][v] = 0;
            for(int j = 0; j <= n; j++) a[i][j] -= a[u][j] * t;
        }
    }
    //是否有解 无解返回false
    bool init_check() {
        while(true) {
            int u = 0, v = 0;
            double mn = -eps;
            for(int i = 1; i <= m; i++) {
                if(a[i][0] < mn && (!u || (rand() & 1))) {
                    mn = a[i][0];
                    u = i;
                }
            }
            if(!u) return true;
            mn = -eps;
            for(int i = 1; i <= n; i++) {
                if(a[u][i] < mn && (!v || (rand() & 1))) {
                    mn = a[u][i];
                    v = i;
                }
            }
            if(!v) return false;
            pivot(u, v);
        }
    }
    //返回false表示解无穷大
    bool do_simplex() {
        while(true) {
            int u = 0, v = 0;
            double mn = 1e15, mx = eps;
            for(int i = 1; i <= n; i++) {
                if(a[0][i] > mx && (!v || (rand() & 1))) {
                    mx = a[0][i];
                    v = i;
                }
            }
            if(!v) return true;
            for(int i = 1; i <= m; i++) {
                if(a[i][v] > eps && a[i][0] / a[i][v] < mn) {
                    mn = a[i][0] / a[i][v];
                    u = i;
                }
            }
            if(!u) return false;
            pivot(u, v);
        }
    }
    // ans[0]表示最终答案
    // ans[i]表示xi的值
    void get_ans() {
        memset(ans, 0, sizeof(ans));
        ans[0] = -a[0][0];
        for(int i = 1; i <= m; i++) {
            if(idy[i] <= n) ans[idy[i]] = a[i][0];
        }
    }
} sf;