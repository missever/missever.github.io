//任意模数fft,模数在int范围内,数组长度1e5可用
//该fft写法用于一般情况下的fft会出错

const int LN = 18;
const int N = 1 << LN;
const double pi = acos(-1.0);
int fa[N],fb[N],fc[N],mod;

int fmod(LL x) {
    return x - x / mod * mod;
}

int mul(int x,int y) {
    return fmod(1LL * x * y);
}

int add(int x,int y) {
    x += y;
    if(x >= mod) x -= mod;
    return x;
}

struct Complex {
    double r,i;
    Complex(double r = 0.0,double i = 0.0):r(r),i(i) {};
    Complex operator + (const Complex &rhs) {
        return Complex(r + rhs.r,i + rhs.i);
    }
    Complex operator - (const Complex &rhs) {
        return Complex(r - rhs.r,i - rhs.i);
    }
    Complex operator * (const Complex &rhs) {
        return Complex(r * rhs.r - i * rhs.i,i * rhs.r + r * rhs.i);
    }
    Complex conj() {
        return Complex(r,-i);
    }
} wn[N];
int bitrev[N];

void fft_prepare() {
    for(int i = 0; i < N; i++) bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) << (LN - 1));
    for(int i = 0; i < N; i++) wn[i] = Complex(cos(2 * pi * i / N),sin(2 * pi * i / N));
}

void FFT(Complex a[],int l,int op) {
    int d = 0;
    while((1 << d) * l != N) d++;
    for(int i = 0; i < l; i++) {
        if(i < (bitrev[i] >> d)) swap(a[i],a[(bitrev[i] >> d)]);
    }
    for (int i = 2; i <= l; i <<= 1){
        int lyc = N / i;
        for (int j = 0; j < l; j += i) {
            Complex *l = a + j, *r = a + j + (i >> 1), *p = wn;
            for(int k = 0; k < (i >> 1); k++) {
                Complex tmp = *r * *p;
                *r = *l - tmp, *l = *l + tmp;
                ++l, ++r, p += lyc;
            }
        }
    }
    if(op == -1) {
        for(int i = 0;i < l; i++) {
            a[i].r /= l;
            a[i].i /= l;
        }
    }
}

Complex va[N],vb[N],da[N],db[N],dc[N],dd[N];
void Conv(int fa[],int fb[],int fc[],int l) {
    int i;
    for(i = 0; i < l; i++) va[i] = Complex(fa[i] & 32767,fa[i] >> 15);
    for(i = 0; i < l; i++) vb[i] = Complex(fb[i] & 32767,fb[i] >> 15);
    FFT(va,l,1);
    FFT(vb,l,1);
    for(i = 0; i < l; i++) {
        int j = (l - i) & (l - 1);
        Complex qa,qb,qc,qd;
        qa = (va[i] + va[j].conj()) * Complex(0.5,0.0);
        qb = (va[i] - va[j].conj()) * Complex(0.0,-0.5);
        qc = (vb[i] + vb[j].conj()) * Complex(0.5,0.0);
        qd = (vb[i] - vb[j].conj()) * Complex(0.0,-0.5);
        da[j] = qa * qc;
        db[j] = qa * qd;
        dc[j] = qb * qc;
        dd[j] = qb * qd;
    }
    for(i = 0; i < l; i++) va[i] = da[i] + db[i] * Complex(0.0,1.0);
    for(i = 0; i < l; i++) vb[i] = dc[i] + dd[i] * Complex(0.0,1.0);
    FFT(va,l,-1);
    FFT(vb,l,-1);
    for(i = 0; i < l; i++) {
        int wa = fmod(va[i].r + 0.5);
        int wb = fmod(va[i].i + 0.5);
        int wc = fmod(vb[i].r + 0.5);
        int wd = fmod(vb[i].i + 0.5);
        fc[i] = add(wa,add(fmod(((LL)add(wb,wc)) << 15),fmod(((LL)wd) << 30)));
    }
}

void solve() {
    fft_prepare();
    //输入数组fa，fb,长度为l,返回fc
    Conv(fa,fb,fc,l);
}
