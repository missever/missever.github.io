//左端点块排序，再右端点排序
bool cmp(const node &a,const node &b)
{
    if(pos[a.l] == pos[b.l]) return (pos[a.l] & 1) ? a.r < b.r : a.r > b.r; //按左端点的块的奇偶性分类排序,减小常数
    else return pos[a.l] < pos[b.l];
}


带单点修改的莫队
const int maxn = 1e5 + 5;
const int mod = 1e9 + 7;
struct node {
    int l, r, t, id;// t 询问时修改操作的时间轴
} f[maxn];
struct cnode {
    int pre, now, id;// 原值 新值 修改位置
} g[maxn];
int pos[maxn], ans[maxn], bsize;
int a[maxn], b[maxn * 10], res, numf, numg;

//左端点块排序，再右端块排序， 最后时间轴排序
bool cmp(const node &a, const node &b) {
    if(pos[a.l] == pos[b.l]) {
        if(pos[a.r] == pos[b.r]) return a.t < b.t;
        else return a.r < b.r;
    } else return pos[a.l] < pos[b.l];
}

void add(int x) {
    if(++b[x] == 1) res++;
}

void del(int x) {
    if(--b[x] == 0) res--;
}

void addt(int k, int i) {
    if(g[k].id >= f[i].l && g[k].id <= f[i].r) {
        del(g[k].pre);
        add(g[k].now);
    }
    a[g[k].id] = g[k].now;
}

void delt(int k, int i) {
    if(g[k].id >= f[i].l && g[k].id <= f[i].r) {
        del(g[k].now);
        add(g[k].pre);
    }
    a[g[k].id] = g[k].pre;
}

int main() {
    int n, m, i, j, k, l, r, t;
    char c;
    scanf("%d%d", &n, &m);
    bsize = pow(n, 2.0 / 3) + 1;
    for(i = j = k = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        pos[i] = j;
        if(k++ == bsize) {
            k = 1;
            j++;
        }
    }
    numf = numg = 0;
    for(i = 1; i <= m; i++) {
        scanf(" %c%d%d", &c, &l, &r);
        if(c == 'Q') f[++numf] = node{l, r, numg, numf};
        else {
            g[++numg] = cnode{a[l], r, l};
            a[l] = r;
        }
    }
    sort(f + 1, f + numf + 1, cmp);
    l = 1;
    r = 0;
    t = numg;
    for(i = 1, res = 0; i <= numf; i++) {
        while(r < f[i].r) add(a[++r]);
        while(l > f[i].l) add(a[--l]);
        while(r > f[i].r) del(a[r--]);
        while(l < f[i].l) del(a[l++]);
        while(t < f[i].t) addt(++t, i);
        while(t > f[i].t) delt(t--, i);
        ans[f[i].id] = res;
    }
    for(i = 1;i <= numf; i++) printf("%d\n", ans[i]);
    return 0;
}

