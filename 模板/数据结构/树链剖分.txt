###树链剖分
//将一个树划分为若干个不相交的路径, 使每个结点仅在一条路径上.
//满足: 从结点u到v最多经过$\log{N}$条路径, 以及$\log{N}$条不在路径上的边.
//采用启发式划分, 即某结点选择与子树中结点数最大的儿子划分为一条路径.
//时间复杂度: 用其他数据结构来维护每条链, 复杂度为所选数据结构乘以 $\log{N}$.
//用两次dfs来进行树链剖分. 对于每一个结点v, 找到它的size最大的子结点u. 如果u不存在, 那么给v分配一条新的路径, 否则v就延续u所属的路径.
//查询两个结点u, v之间的路径是, 首先判断它们是否属于同一路径. 如果不是, 选择所属路径顶端结点h的深度较大的结点, 不妨假设是v, 查询v到h, 并令v = father[h]继续查询, 直至u, v属于同一路径. 最后在这条路径上查询并返回.
```
/*
sz[u]: 结点u的子树的结点数量
fa[u]: 结点u的父结点
dep[u]: 结点u在树中的深度
son[u]: 结点u的重儿子
dfn[u]: 树中结点u的dfs序,按先重链后轻链的顺序
id[i]: dfs序为i的结点
top[u]: 结点u所在链的第一个结点
*/
vector<int> g[maxn];
int sz[maxn], fa[maxn], dep[maxn], son[maxn];
int top[maxn], dfn[maxn];
int cnt = 0;

void dfs1(int u, int father) {
    dep[u] = dep[father] + 1;
    fa[u] = father;
    sz[u] = 1;
    son[u] = -1;
    for(auto v : g[u]) {
        if(v == father) continue;
		dfs1(v, u);
        sz[u] += sz[v];
        if(son[u] == -1 || sz[v] > sz[son[u]]) son[u] = v;
    }
}

void dfs2(int u, int t) {
    top[u] = t;
    dfn[u] = ++cnt;
    if(son[u] == -1) return;
    dfs2(son[u], t);
    for(auto v : g[u]) {
        if(v == son[u] || v == fa[u]) continue;
        dfs2(v, v);
    }
}
void query(int u, int v) {
    int x = top[u], y = top[v];
    while(x != y) {
        int &w = dep[x] > dep[y] ? u : v;
        int &z = dep[x] > dep[y] ? x : y;
        //query(dfn[z] -->  dfn[w])
        w = fa[z];
        z = top[w];
    }
    if(dfn[u] > dfn[v]) swap(u, v);
    //query(dfn[u] --> dfn[v])
}
```

dfs1(1, 0);
dfs2(1, 1);