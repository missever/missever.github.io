//带删除查询版


#define MAXN 1000000
int ch[MAXN][2],f[MAXN],size[MAXN],cnt[MAXN],key[MAXN];
int sz,root;
inline void clear(int x) {
    ch[x][0]=ch[x][1]=f[x]=size[x]=cnt[x]=key[x]=0;
}
inline bool get(int x) {
    return ch[f[x]][1]==x;
}
inline void update(int x) {
    if (x) {
        size[x]=cnt[x];
        if (ch[x][0]) size[x]+=size[ch[x][0]];
        if (ch[x][1]) size[x]+=size[ch[x][1]];
    }
}
inline void rotate(int x) {
    int old=f[x],oldf=f[old],whichx=get(x);
    ch[old][whichx]=ch[x][whichx^1];
    f[ch[old][whichx]]=old;
    ch[x][whichx^1]=old;
    f[old]=x;
    f[x]=oldf;
    if (oldf)
        ch[oldf][ch[oldf][1]==old]=x;
    update(old);
    update(x);
}
inline void splay(int x) {
    for (int fa; fa=f[x]; rotate(x))
        if (f[fa])
            rotate((get(x)==get(fa))?fa:x);
    root=x;
}
// 插入x
inline void insert(int x) {
    if (root==0) {
        sz++;
        ch[sz][0]=ch[sz][1]=f[sz]=0;
        root=sz;
        size[sz]=cnt[sz]=1;
        key[sz]=x;
        return;
    }
    int now=root,fa=0;
    while(1) {
        if (x==key[now]) {
            cnt[now]++;
            update(now);
            update(fa);
            splay(now);
            break;
        }
        fa=now;
        now=ch[now][key[now]<x];
        if (now==0) {
            sz++;
            ch[sz][0]=ch[sz][1]=0;
            f[sz]=fa;
            size[sz]=cnt[sz]=1;
            ch[fa][key[fa]<x]=sz;
            key[sz]=x;
            update(fa);
            splay(sz);
            break;
        }
    }
}
// 查询x的最小排名
inline int find(int x) {
    int now=root,ans=0;
    while(1) {
        if (x<key[now])
            now=ch[now][0];
        else {
            ans+=(ch[now][0]?size[ch[now][0]]:0);
            if (x==key[now]) {
                splay(now);
                return ans+1;
            }
            ans+=cnt[now];
            now=ch[now][1];
        }
    }
}
// 查询排名为x的数
inline int findx(int x) {
    int now=root;
    while(1) {
        if (ch[now][0]&&x<=size[ch[now][0]])
            now=ch[now][0];
        else {
            int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now];
            if (x<=temp) return key[now];
            x-=temp;
            now=ch[now][1];
        }
    }
}
inline int pre() {
    int now=ch[root][0];
    while (ch[now][1]) now=ch[now][1];
    return now;
}
inline int next() {
    int now=ch[root][1];
    while (ch[now][0]) now=ch[now][0];
    return now;
}
// 删除x,有多个仅删除一个
inline void del(int x) {
    find(x);
    if (cnt[root]>1) {
        cnt[root]--;
        update(root);
        return;
    }
    if (!ch[root][0]&&!ch[root][1]) {
        clear(root);
        root=0;
        return;
    }
    if (!ch[root][0]) {
        int oldroot=root;
        root=ch[root][1];
        f[root]=0;
        clear(oldroot);
        return;
    } else if (!ch[root][1]) {
        int oldroot=root;
        root=ch[root][0];
        f[root]=0;
        clear(oldroot);
        return;
    }
    int leftbig=pre(),oldroot=root;
    splay(leftbig);
    ch[root][1]=ch[oldroot][1];
    f[ch[oldroot][1]]=root;
    clear(oldroot);
    update(root);
}
// 寻找x的前驱(最大的小于x的数)
inline int find_pre(int x) {
     insert(x);
     int w = key[pre()];
     del(x);
     return w;
}
// 寻找x的后继(最小的大于x的数)
inline int find_next(int x) {
     insert(x);
     int w = key[next()];
     del(x);
     return w;
}




// 带lazy标记区间修改版

const int INF = 2e9 + 1e8;
const int maxn = 1e6 + 10;
struct SplayTree {
    struct Node {
        int son[2], big, val, lazy, sz;
        bool rev;
        void init(int _val) {
            val = big = _val;
            sz = 1;
            lazy = son[0] = son[1] = rev = 0;
        }
    } T[maxn];
    // 初始数组为a
    int root, fa[maxn],a[maxn];
    void pushup(int i) {
        T[i].big=T[i].val,T[i].sz=1;
        if(T[i].son[0]) {
            T[i].big=max(T[i].big,T[T[i].son[0]].big);
            T[i].sz+=T[T[i].son[0]].sz;
        }
        if(T[i].son[1]) {
            T[i].big=max(T[i].big,T[T[i].son[1]].big);
            T[i].sz+=T[T[i].son[1]].sz;
        }
    }
    void pushdown(int i) {
        if(i == 0) return;
        if(T[i].lazy) {
            for(int k = 0; k < 2; k++) {
                if(T[i].son[k]) {
                    T[T[i].son[k]].lazy += T[i].lazy;
                    T[T[i].son[k]].val += T[i].lazy;
                    T[T[i].son[k]].big += T[i].lazy;
                }
            }
            T[i].lazy = 0;
        }
        if(T[i].rev) {
            for(int k = 0; k < 2; k++)
                if(T[i].son[k]) T[T[i].son[k]].rev ^= 1;
            swap(T[i].son[0], T[i].son[1]);
            T[i].rev = 0;
        }
    }
    /**  旋转操作
     * 传入x，旋转x与x的父亲这两个节点；
     */
    void rotate(int x, int d) {
        int y = fa[x], z = fa[y];
        T[y].son[!d] = T[x].son[d], fa[T[x].son[d]] = y;
        T[x].son[d] = y, fa[y] = x;
        T[z].son[T[z].son[1] == y] = x, fa[x] = z;
        pushup(y);
    }
    void splay(int x, int goal) {
        if(x == goal) return;
        while (fa[x] != goal) {
            int y = fa[x], z = fa[y];
            pushdown(z), pushdown(y), pushdown(x);
            int dirx = (T[y].son[0] == x), diry = (T[z].son[0] == y);
            if(z == goal) rotate(x, dirx);
            else {
                if(dirx == diry) rotate(y, diry);
                else rotate(x, dirx);
                rotate(x, diry);
            }
        }
        pushup(x);
        if(goal == 0) root = x;
    }
    /**
     * select(pos) 返回第pos+1个元素；
     */
    int Select(int pos) {
        int u = root;
        pushdown(u);
        while(T[T[u].son[0]].sz != pos) {
            if(pos < T[T[u].son[0]].sz) u = T[u].son[0];
            else {
                pos = pos - (1 + T[T[u].son[0]].sz);
                u = T[u].son[1];
            }
            pushdown(u);
        }
        return u;
    }
    //区间[l,r] 加 val
    void update(int l, int r, int val) {
        int x = Select(l - 1), y = Select(r + 1);
        splay(x, 0);
        splay(y, x);
        T[T[y].son[0]].val += val;
        T[T[y].son[0]].big += val;
        T[T[y].son[0]].lazy += val;
    }
    // 翻转[l,r]区间
    void turn(int l, int r) {
        int x = Select(l - 1), y = Select(r + 1);
        splay(x, 0);
        splay(y, x);
        T[T[y].son[0]].rev ^= 1;
    }
    // 求区间[l,r]的最大值
    int query(int l, int r) {
        int x = Select(l - 1), y = Select(r + 1);
        splay(x, 0);
        splay(y, x);
        return T[T[y].son[0]].big;
    }
    int build(int L, int R) {
        if(L > R) return 0;
        if(L == R) return L;
        int mid = (L + R) >> 1, sL, sR;
        T[mid].son[0] = sL = build(L, mid - 1);
        T[mid].son[1] = sR = build(mid + 1, R);
        fa[sL] = fa[sR] = mid;
        pushup(mid);
        return mid;
    }
    void init(int n) {
        T[1].init(-INF), T[n + 2].init(-INF);
        // 初始化splay树
        for(int i = 2; i <= n + 1; i++) T[i].init(a[i - 1]);
        root = build(1, n + 2), fa[root] = 0;
        fa[0] = 0, T[0].son[1] = root, T[0].sz = 0;
    }
} re;