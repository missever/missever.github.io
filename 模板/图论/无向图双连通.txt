typedef pair<int,int> P;
const int maxn = 1e5 + 5;
vector<int> g[maxn],g_bcc[maxn];
int pre[maxn],low[maxn],bcc[maxn];
bool iscut[maxn];//是否为割点
int dfs_t,bcc_cnt;
stack<P> ST;

// 求无向图点双联通
// 任意两点存在两条以上边不重复的路径称为边双联通
// 任意两点存在两条以上点不重复的路径称为点双联通
// 对于无向图，任意边只属于一个点双联通分量，但点可能属于多个点双联通分量
// g_bcc 保存一个点双联通的点集
void dfs(int u,int fa) {
    pre[u] = low[u] = ++dfs_t;
    int child = 0;
    for(auto v:g[u]) {
        if(!pre[v]) {
            ST.push(P(u,v));
            child++;
            dfs(v,u);
			low[u] = min(low[u], low[v]);
            //if(low[v] > pre[u]) edge(u,v)就是桥
            if(low[v] >= pre[u]) {
                iscut[u] = true;
                g_bcc[++bcc_cnt].clear();
                while(!ST.empty()) {
                    P e = ST.top();
                    ST.pop();
                    if(bcc[e.first] != bcc_cnt) {
                        g_bcc[bcc_cnt].push_back(e.first);
                        bcc[e.first] = bcc_cnt;
                    }
                    if(bcc[e.second] != bcc_cnt) {
                        g_bcc[bcc_cnt].push_back(e.second);
                        bcc[e.second] = bcc_cnt;
                    }
                    if(e.first == u && e.second == v) break;
                }
            }
        } else if(pre[v] < pre[u] && v != fa) {
            ST.push(P(u,v));
            low[u] = min(low[u],pre[v]);//用反向边更新自己
        }
    }
    if(fa == 0 && child > 1) iscut[u] = 1;
}

void find_bcc(int n) {
	memset(pre, 0, sizeof(pre);
	memset(iscut, 0, sizeof(iscut);
	memset(bcc, 0, sizeof(bcc));
	dfs_t = bcc_cnt = 0;
	for(int i = 1;i <= n; i++) {
		if(!pre[i]) dfs(i, 0);
	}
}