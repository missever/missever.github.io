const int maxn = 1e5 + 5;
vector<int> g[maxn];
int pre[maxn],low[maxn],scc[maxn];
int dfs_t,scc_cnt;
stack<int> ST;

// 有向图求强联通
void dfs(int u) {
    pre[u] = low[u] = ++dfs_t;
    ST.push(u);
    for(auto v:g[u]) {
        if(!pre[v]) {
            dfs(v);
            low[u] = min(low[u],low[v]);
        } else if(!scc[v]) {
            low[u] = min(low[u],pre[v]);
        }
    }
    if(low[u] == pre[u]) {
        scc_cnt++;
        while(!ST.empty()) {
            int x = ST.top();
            ST.pop();
            scc[x] = scc_cnt;
            if(x == u) break;
        }
    }
}

vector<int>g2[maxn];
//有向图缩点
void Shrink_Point(int m,int n) {
    for(int i = 1;i <= m; i++) g2[i].clear();
    for(int u = 1; u <= n; u++) {
        for(auto v:g[u]) {
            if(scc[u] != scc[v]) {
                g2[scc[u]].push_back(scc[v]);
            }
        }
    }
}

void find_scc(int n) {
    dfs_t = scc_cnt = 0;
    memset(scc,0,sizeof(scc));
    memset(pre,0,sizeof(pre));
    for(int i = 1; i <= n; i++) {
        if(!pre[i]) dfs(i);
    }
    Shrink_Point(scc_cnt,n);
}