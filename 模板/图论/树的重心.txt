树的重心的一个的性质：
树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么他们的距离和一样。
这也是“道路修建”带来的启发。（证明：调整法）

树的重心的另一个性质：
把两个树通过一条边相连得到一个新的树，那么新的树的重心在连接原来两个树的重心的路径上。
这个让“重心”名副其实了。。。（证明：。。。自己好好思考一下吧。。。）

还有一个性质：
把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。

求重心方法：一遍dfs，维护当前结点的子树大小

h 为重心点
const int maxn = 1e5 + 5;
vector<int> g[maxn];
int son[maxn],h,m,nn;
long long ans;

void dfs1(int u,int fa)
{
    son[u] = 0;
    int d = 0;
    for(auto v:g[u])
    {
        if(v == fa) continue;
        dfs1(v,u);
        son[u] += son[v] + 1;
        d = max(d,son[v] + 1);
    }
    d = max(d,nn - son[u] - 1);
    if(d < m)
    {
        m = d;
        h = u;
    }
}