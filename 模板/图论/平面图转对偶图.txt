typedef long long LL;
typedef pair<int,int> P;
typedef pair<int,P> PI;
typedef pair<double,int> PD;

const int maxn = 2e5 + 5;
const double eps = 1e-8;
const double pi = acos(-1);
inline int sgn(double x) {
    if(x < -eps) return -1;
    else if(x > eps) return 1;
    else return 0;
}
struct Point {
    int x,y;
    Point(int _x = 0,int _y = 0): x(_x),y(_y) {}
    Point operator + (const Point &b) const {
        return Point(x + b.x,y + b.y);
    }
    Point operator - (const Point &b) const {
        return Point(x - b.x,y - b.y);
    }
    LL operator * (const Point &b) const {
        return (1LL * x * b.x + 1LL * y * b.y);
    }
    LL operator ^ (const Point &b) const {
        return (1LL * x * b.y - 1LL * y * b.x);
    }
};
Point p[maxn];
P f[maxn];
int n,m,num,id[maxn * 2];
bool vis[maxn * 2];
map<P,int> mp;
vector<PD> g[maxn];
unordered_map<int,int> gg[maxn];
int sk;

double get_ang(int u,int v) {
    return atan2(p[v].y - p[u].y,p[v].x - p[u].x);
}

//f数组表示该简单多边形的边
//id表示这条边所属的两个块
void work(int u,PD e) {
    int v1 = u,v2 = e.second,k = 0;
    f[k++] = P(v1,v2);
    while(v2 != u) {
        v1 = gg[v2][v1];
        if(v1 == 0) v1 = g[v2].back().second;
        else v1 = g[v2][v1 - 1].second;
        swap(v1,v2);
        f[k++] = P(v1,v2);
    }
    ++num;
    for(int i = 0; i < k; i++) {
        assert(mp.find(f[i]) != mp.end());
        int j = mp[f[i]];
        assert(!vis[j]);
        vis[j] = 1;
        id[j] = num;
    }
//    LL ss = 0;
//    for(int i = 0; i < k; i++) ss += p[f[i].first] ^ p[f[i].second];
// ss小于0表示是外边界
}


bool cmp(const PD &a,const PD &b) {
    if(sgn(b.first - a.first) == 0) return ((p[b.second] - p[sk]) ^ (p[a.second] - p[sk])) < 0;
    else return b.first - a.first > eps;
}

void build() {
    int i,j;
    for(i = 1; i <= n; i++) {
        sk = i;
        sort(g[i].begin(),g[i].end(),cmp);
        for(j = 0; j < (int)g[i].size(); j++) gg[i][g[i][j].second] = j;
    }
    for(i = 1; i <= n; i++) {
        for(auto e:g[i]) {
            j = mp[P(i,e.second)];
            if(vis[j]) continue;
            work(i,e);
        }
    }
}

void init() {
    num = 0;
    mp.clear();
    memset(vis,0,sizeof(vis));
    for(int i = 1; i <= n; i++) g[i].clear();
    for(int i = 1; i <= n; i++) gg[i].clear();
}

int w[maxn],pf[maxn],fu[maxn];

int ff(int u) {
    if(pf[u] != u) pf[u] = ff(pf[u]);
    return pf[u];
}

bool cmp2(const int &a,const int &b) {
    return w[a] < w[b];
}

void solve() {
    int i,j,u,v;
    init();
    for(i = 1; i <= n; i++) scanf("%d%d",&p[i].x,&p[i].y);
    for(i = 0; i < m; i++) {
        scanf("%d%d%d",&u,&v,&w[i]);
        g[u].push_back(PD(get_ang(u,v),v));
        g[v].push_back(PD(get_ang(v,u),u));
        mp[P(u,v)] = i << 1;
        mp[P(v,u)] = i << 1 | 1;
    }
    build();
}