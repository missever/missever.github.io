vector <int> a[N], b[N], pre[N];
int dfn[N], cnt, idom[N], semi[N], f[N], best[N], n, m, id[N], fa[N];
long long ans[N];
// idom[x] 最近支配点 即到起点的路径上距离x最近的必经点
// semi[x] 最小半必经点 在dfs搜索树上x的祖先中能通过非树枝边到达x的深度最小的祖先
void input(int &r) { //手动读入
    char t;
    t = getchar();
    while (!isdigit(t)) t = getchar();
    r = 0;
    while (isdigit(t)) r = r * 10 + t - '0', t = getchar();
}

void init() { //初始化
    for (int i = 1; i <= n; i++)
        f[i] = best[i] = i;
    for (int i = 1; i <= n; i++)
        a[i].clear(), b[i].clear(), pre[i].clear(), id[i] = 0;
    for (int i = 1; i <= n; i++)
        dfn[i] = semi[i] = idom[i] = 0, fa[i] = 0, ans[i] = 0;
    cnt = 0;
}

void Dfs(int x) {
    dfn[x] = ++cnt;
    id[cnt] = x;//id[x]记录的是时间戳为x的节点是谁。
    int len = a[x].size();
    for (int i = 0; i <= len - 1; i++) {
        int y = a[x][i];
        if (!dfn[y])
            Dfs(y), fa[y] = x;
    }
}

bool cmp(int x, int y) {
    return dfn[semi[x]] < dfn[semi[y]];
}

int ff(int x) {
    if (f[x] == x)
        return x;
    int olfa = f[x];
    f[x] = ff(f[x]);
    best[x] = min(best[x], best[olfa], cmp);
    return f[x];
}

void Lengauer_Tarjan() {
    Dfs(n);//dfs获取时间戳,这里的起点为n
    dfn[0] = 0x3f3f3f3f;//这是一个很大的数,一开始的semi都是0,就让他的时间戳无穷大，就不会更新了
    for (int i = cnt; i >= 1; i--) { //时间戳从大到小处理
        int x = id[i];
        if (i != 1) {
            int len = b[x].size();//b是逆向边
            for (int j = 0; j <= len - 1; j++) {
                int y = b[x][j];
                if (!dfn[y]) continue;
                if (dfn[y] > dfn[x]) { //如果是dfs序大于的x节点的情况
                    //这个并查集里面包括的是时间戳大于某个节点且能够到达这个节点的点
                    ff(y);//找到所有大于这个节点x的dfs序的节点(一定要是能够到达x节点)
                    if (dfn[semi[best[y]]] < dfn[semi[x]])//如果时间戳最小的点的半必经点更优
                        semi[x] = semi[best[y]];//替换这个点的半必经点
                } else if (dfn[y] < dfn[semi[x]]) //这是它的直系父亲(dfn[p]<dfn[x])
                    semi[x] = y;//如果它的时间戳比之前更新的都小。那么它变成半必经点
            }
            pre[semi[x]].push_back(x);//记录那个半必经点是相对于谁的半必经点
        }
        while (pre[x].size()) { //这个相当于处理出x和semi[x]之间的那个y了。
            int y = pre[x].back();
            pre[x].pop_back();
            ff(y);
            //值得注意的是。因为我们是时间戳从大到小的顺序处理的。
            //所以semi[x]->x路径上的所有点必然已经加入到并查集中。
            //且semi[x]上面的点肯定没有包括在并查集中
            //因为semi[x]上面的点的时间戳肯定是小于semi[x]的；
            //而那些点我们等一下才要处理。
            if (semi[best[y]] != x)//如果在semi[y]->y之间存在一个点z
                //它的半必经点不等于y的半必经点 则说明要让idom[y] = idom[z];
                //但是idom[z]可能还没有处理出来。
                //所以我们就仅仅记录这个点z是什么.之后再处理
                idom[y] = best[y];
            else//如果等于的话,idom[y] = semi[y];
                idom[y] = x;
        }
        int len = a[x].size();
        for (int j = 0; j <= len - 1; j++) { //然后把这个点加入到并查集维护的森林中
            //当然。只有那些和他有关系的点(能够从这个点到达的点才要加入);
            int y = a[x][j];
            if (fa[y] == x)
                f[y] = x;
        }
    }
    for (int i = 2; i <= cnt; i++) {
        int x = id[i];
        if (idom[x] != semi[x])//这个利用上面处理出来的semi[x]->x路径上的点
            //利用必经点定理修改必经点
            idom[x] = idom[idom[x]];
    }
    idom[id[1]] = 0;
}

long long get_ans(int x) { //这个就是累加答案。
    if (x == n) {
        ans[x] = n;
        return ans[x];
    }
    if (ans[x])//用了记搜~~
        return ans[x];
    ans[x] = get_ans(idom[x]) + x;
    return ans[x];
}

int main() {
    while (~scanf("%d%d", &n, &m)) {
        init();
        for (int i = 1; i <= m; i++) {
            int x, y;
            input(x);
            input(y);
            a[x].push_back(y);
            b[y].push_back(x);//反向边用于找其直系爸爸和大于这个时间戳的和它有关的节点。
        }
        Lengauer_Tarjan();
        for (int i = 1; i <= n; i++)
            printf("%I64d%c", dfn[i] ? get_ans(i) : 0, i == n ? '\n' : ' ');
    }
    return 0;
}
