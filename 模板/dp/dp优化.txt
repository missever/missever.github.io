
单调队列优化：
有些DP方程可以转化成DP[i]=f[j]+x[i]的形式，其中f[j]中保存了只与j相关的量。这样的DP方程我们可以用单调队列进行优化


斜率优化：
对于这样的一类DP方程f[i]=min{a[i]*x[j]+b[j]}
a[i]是和i有关的函数，x[j],b[j]是和j有关的函数或常数
我们可以把它改写成这个样子-a[i]*x[j]+f[i]=b[j]
把-a[i]看做斜率，f[i]看做截距，每一个决策相当于平面上一个点，最优决策显然在平面点集的凸包上，要求f[i]的最小值，就相当于将一条斜率为-a[i]的直线不断向上平移，碰到的第一个点就是截距最小的点，也就是f[i]的最优决策，如果横坐标和斜率均单调，我们就可以维护一个单调队列（斜率是单调的，即最优解也是单调的（类似于决策单调）），队首指针不断往后走，每个点只会访问一次，复杂度为O(n)
如果均不单调，有时我们可以排序使得其中一个单调
或者维护一个单调的斜率，对每一个值在上面二分答案
另：如果方程是f[i]=min{a[i]*x[j]+b[i]*y[j]}的话，可以将其变为
f[i]=min(a[i]/b[i]*x[j]+y[j])*b[i]

g[i,j]表示两点构成的斜率表达式
1，用一个单调队列来维护解集。
2，假设队列中从头到尾已经有元素a b c。那么当d要入队的时候，我们维护队列的上凸性质，即如果g[d,c]<g[c,b]，那么就将c点删除。直到找到g[d,x]>=g[x,y]为止，并将d点加入在该位置中。
3，求解时候，从队头开始，如果已有元素a b c，当i点要求解时，如果g[b,a]<k[i](k[i]表示i点的方程的斜率)，那么说明b点比a点更优，a点可以排除，于是a出队。最后dp[i]=getDp(q[head])。



四边形不等式优化：
最有代价用d[i,j]表示 d[i,j]=min{d[i,k-1]+d[k+1,j]}+w[i,j] 
(一维)f[j] = min(f[i]+w[i,j])
四边形不等式   w[a,c]+w[b,d]<=w[b,c]+w[a,d](a<b<c<d) 就称其满足凸四边形不等式
//一般需证明w[i,j]+w[i+1,j+1]<=w[i+1,j]+w[i,j+1]
决策单调性   w[i,j]<=w[i',j']   ([i,j]属于[i',j']) 既 i'<=i<j<=j'
//max时不等号取反……

于是有以下三个定理 
定理一： 如果w同时满足四边形不等式 和 决策单调性 ,则d也满足四边形不等式
定理二：当定理一的条件满足时，让d[i,j]取最小值的k为K[i,j]，则K[i,j-1]<=K[i,j]<=K[i+1,j] 
定理三：w为凸当且仅当w[i,j]+w[i+1,j+1]<=w[i+1,j]+w[i,j+1]
由定理三知 判断w是否为凸即判断 w[i,j+1]-w[i,j]的值随着i的增加是否递减
于是求K值的时候K[i,j]只和K[i+1,j] 和 K[i,j-1]有关，所以 可以以i-j递增为顺序递推各个状态值最终求得结果

//http://blog.csdn.net/guognib/article/details/40081523
常见方式：
s为决策区间//w[i][j]可以与k有关
dp[i][j] = min{dp[i][k] + dp[k + 1][j] + w[i][j] }, i <= k <= j - 1
s[i][j - 1] <= s[i][j] <= s[i + 1][j] //s[i][i] = i;

dp[i][j] = min{dp[i - 1][k] + w[k + 1][j]}, i - 1 <= k <= j - 1
s[i - 1][j] <= s[i][j] <= s[i][j + 1] //s[i][n + 1] = n;

dp[i][j] = min{dp[k][j - 1] + w[k + 1][j]}, j - 1 <= k <= i - 1
s[i][j - 1] <= s[i][j] <= s[i + 1][j] //s[n + 1][i] = n;
