//acos函数返回值在[0,pi]之间
//atan()用来计算参数x 的反正切值 返回(-PI/2,PI/2) 之间的计算结果,误差较大
//atan2(double y,double x)计算y/x,返回(-pi,pi],误差较大
//asin 返回[－PI/2,PI/2] 之间
//double精度15-16位，long double 18-19位
//sqrt里面用int容易爆,注意加eps防止负数开根号
//判断点是否是线段的端点时、尽量判距离，不要用点乘或叉乘，有精度误差
//二分三分的上下界注意精度问题，尽量精准

const double eps = 1e-8;
const double pi = acos(-1);
inline int sgn(double x)
{
    if(x < -eps) return -1;
    else if(x > eps) return 1;
    else return 0;
}
struct Point
{
    double x,y;
    Point(double _x = 0.0,double _y = 0.0): x(_x),y(_y) {}
    Point operator + (const Point &b) const
    {
        return Point(x + b.x,y + b.y);
    }
    Point operator - (const Point &b) const
    {
        return Point(x - b.x,y - b.y);
    }
    double operator * (const Point &b) const//点乘
    {
        return (x * b.x + y * b.y);
    }
    double operator ^ (const Point &b) const//叉乘，判断b点的相对于该点位置关系 左正右负
    {
        return (x * b.y - y * b.x);
    }
    Point operator * (double b)
    {
        return Point(x * b,y * b);
    }
    bool operator < (const Point &b) const { //水平序比较
        if(sgn(x - b.x) == 0) return y < b.y;
        else return x < b.x;
    }
    Point rot(double ang)//旋转，输入角度
    {
        return Point(x * cos(ang) - y * sin(ang),x * sin(ang) + y * cos(ang));
    }
    Point rot(double g1,double g2)//旋转，输入正弦值，余弦值
    {
        return Point(x * g2 - y * g1,x * g1 + y * g2);
    }
    double norm()//求模
    {
        return sqrt(x * x + y * y);
    }
    Point unit()//取单位向量
    {
        double ll = norm();
        return Point(x / ll,y / ll);
    }
};

//极角排序 关于(0,0)点
bool cmp(const Point &A,const Point &B)
{
    return atan2(B.y,B.x) - atan2(A.y,A.x) > eps;//计算极角法
    //精度不足时可考虑在角度小于eps时进行叉乘判断
B ^ A < 0
}

struct Line//两点式
{
    Point s,e;
    Line(){}
    Line(Point _s,Point _e)
    {
        s = _s;
        e = _e;
    }
    //求两直线交点，-1重合，0相交，1平行
    pair<int,Point> operator &(Line b)
    {
        if(sgn((s - e) ^ (b.s - b.e)) == 0)
        {
            if(sgn((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(-1,e);
            else return make_pair(1,s);
        }
        double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));
        return make_pair(0,Point(s.x + (e.x - s.x) * t,s.y + (e.y - s.y) * t));
    }
};

double dist(Point a,Point b)
{
    return (a - b).norm();
}
//判断点p在线段l上,包含端点
bool isPointOnSegment(Point p,Line l)
{
    return sgn((p - l.s) ^ (l.s - l.e)) == 0 && sgn((p.x - l.s.x) * (p.x - l.e.x)) <= 0 && sgn((p.y - l.s.y) * (p.y - l.e.y)) <= 0;
}
//判断点p在直线l上
bool isPointOnLine(Point p,Line l)
{
    return sgn((p - l.s) ^ (l.s - l.e)) == 0;
}
//判断两线段相交
bool seg_seg_inter(Line seg1,Line seg2)
{
    return
    sgn(max(seg1.s.x,seg1.e.x) - min(seg2.s.x,seg2.e.x)) >= 0 &&
    sgn(max(seg2.s.x,seg2.e.x) - min(seg1.s.x,seg1.e.x)) >= 0 &&
    sgn(max(seg1.s.y,seg1.e.y) - min(seg2.s.y,seg2.e.y)) >= 0 &&
    sgn(max(seg2.s.y,seg2.e.y) - min(seg1.s.y,seg1.e.y)) >= 0 &&
    sgn((seg2.s - seg1.e) ^ (seg1.s - seg1.e)) * sgn((seg2.e - seg1.e) ^ (seg1.s - seg1.e)) <= 0 &&
    sgn((seg1.s - seg2.e) ^ (seg2.s - seg2.e)) * sgn((seg1.e - seg2.e) ^ (seg2.s - seg2.e)) <= 0;
}
//判断直线与线段相交
bool seg_line_inter(Line l,Line seg)
{
    return sgn((seg.s - l.e) ^ (l.s - l.e)) * sgn((seg.e - l.e) ^ (l.s - l.e)) <= 0;
}
//点到直线距离，返回垂足
Point Point_to_Line(Point p,Line l)
{
    double t = ((p - l.s) * (l.e - l.s)) / ((l.e - l.s) * (l.e - l.s));
    return Point(l.s.x + (l.e.x - l.s.x) * t,l.s.y + (l.e.y - l.s.y) * t);
}
//点到线段距离，返回点到直线最近点
Point Point_to_Seg(Point p,Line seg)
{
    double t = ((p - seg.s) * (seg.e - seg.s)) / ((seg.e - seg.s) * (seg.e - seg.s));
    if(t >= 0 && t <= 1) return Point(seg.s.x + (seg.e.x - seg.s.x) * t,seg.s.y + (seg.e.y - seg.s.y) * t);
    else if(sgn(dist(p,seg.s) - dist(p,seg.e)) <= 0) return seg.s;
    else return seg.e;
}
//求向量夹角，小于等于pi
double angle(Point vA,Point vB)
{
    double tmp = vA.norm() * vB.norm();
    if(sgn(tmp) != 0) return acos((vA * vB) / tmp);
    else return 0.0;
}
//返回vA到vB的逆时针角度大小
double angle(Point vA,Point vB)
{
    double ang_1 = atan2(vA.y,vA.x);
    double ang_2 = atan2(vB.y,vB.x);
    ang_2 -= ang_1;
    if(sgn(ang_2) == -1) ang_2 += pi * 2.0;
    return ang_2;
}

//判断两圆关系，-1相离，0相交，1第一个圆内含第二个，2第二个圆内含第一个,3重合，4外切，5内切第一个在内，6内切第二个在内
int dot_to_circle(Point o1,double r1,Point o2,double r2)
{
    if(sgn(dist(o1,o2)) == 0 && sgn(r1 - r2) == 0) return 3;
    int k = sgn(dist(o1,o2) - r1 - r2);
    if(k < 0)
    {
        k = sgn(dist(o1,o2) - fabs(r1 - r2));
        if(k > 0) return 0;
        if(k == 0)
        {
            if(sgn(r1 - r2) > 0) return 6;
            else return 5;
        }
        if(sgn(r1 - r2) > 0) return 1;
        else return 2;
    }
    else if(k == 0) return 4;
    else return -1;
}
//两圆面积交
double area_of_circle(Point o1,double r1,Point o2,double r2)
{
    int k = dot_to_circle(o1,r1,o2,r2);
    if(k == -1 || k == 4) return 0.0;
    else if(k != 0) return pi * min(r1,r2) * min(r1,r2);
    double d = dist(o1,o2);
    double ang_1 = acos((d * d + r1 * r1 - r2 * r2) / (2.0 * d * r1));
    double ang_2 = acos((d * d + r2 * r2 - r1 * r1) / (2.0 * d * r2));
    return ang_1 * r1 * r1 + ang_2 * r2 * r2 - r1 * d * sin(ang_1);
}
//求两圆交点
void point_of_circle(Point o1,double r1,Point o2,double r2,Point &p1,Point &p2)
{
    double l = dist(o1,o2);
    double d1 = (l * l - r2 * r2 + r1 * r1) / (2.0 * l);
    double d2 = r1 * r1 - d1 * d1;
    if(d2 < 0) d2 = 0;
    else d2 = sqrt(d2);
    Point mid = o1 + (o2 - o1).unit() * d1;
    Point vv = (o2 - o1).rot(pi / 2.0).unit() * d2;
    p1 = mid + vv;
    p2 = mid - vv;
}

//圆(O,r)与直线(线段)l相交，num表示交点数，res存储交点
void Circle_cross_Segment(Point o,double r,Line l,Point res[],int &num)
{
    double dx = l.e.x - l.s.x;
    double dy = l.e.y - l.s.y;
    double A = dx * dx + dy * dy;
    double B = 2.0 * dx * (l.s.x - o.x) + 2.0 * dy * (l.s.y - o.y);
    double C = (l.s.x - o.x) * (l.s.x - o.x) + (l.s.y - o.y) * (l.s.y - o.y) - r * r;
    double delta = B * B - 4.0 * A * C;
    num = 0;
    if(sgn(delta) < 0) return;
    delta = sqrt(max(0.0,delta));
    double k1 = (-B - delta) / (2.0 * A);
    double k2 = (-B + delta) / (2.0 * A);
    //if(sgn(k1 - 1.0) <= 0 && sgn(k1) >= 0) //线段相交判断
    res[num++] = Point(l.s.x + k1 * dx,l.s.y + k1 * dy);
    //if(sgn(k2 - 1.0) <= 0 && sgn(k2) >= 0) //线段相交判断
    res[num++] = Point(l.s.x + k2 * dx,l.s.y + k2 * dy);
}

//三角形ABO与圆(O,r)面积交
double Triangel_cross_Circle(Point A, Point B, Point O, double r) {
    double a,b,c,x,y,s = 0.5 * ((A - O) ^ (B - O));
    a = (B - O).norm();
    b = (A - O).norm();
    c = (A - B).norm();
    if(a <= r && b <= r) return s;
    else if(a < r && b >= r) {
        x = ((A - B) * (O - B) + sqrt(c * c * r * r - sqr((A - B) ^ (O - B)))) / c;
        return asin(s * (c - x) * 2.0 / c / b / r) * r * r * 0.5 +s * x / c;
    } else if(a >= r && b < r) {
        y = ((B - A) * (O - A) + sqrt(c * c * r * r - sqr((B - A) ^ (O - A)))) / c;
        return asin(s * (c - y) * 2.0 / c / a / r) * r * r * 0.5 +s * y / c;
    } else {
        if(fabs(2.0 * s) >= r * c || (B - A) * (O - A) <= 0 || (A - B) * (O - B) <= 0) {
            if((A - O) * (B - O) < 0) {
                if(((A - O) ^ (B - O)) < 0) return (-pi - asin(s * 2.0 / a / b)) * r * r * 0.5;
                else return (pi - asin(s *2.0 / a / b)) * r * r * 0.5;
            } else return asin(s * 2 / a / b) * r * r * 0.5;
        } else {
            x = ((A - B) * (O - B) + sqrt(c * c * r * r - sqr((A - B) ^ (O - B)))) / c;
            y = ((B - A) * (O - A) + sqrt(c * c * r * r - sqr((B - A) ^ (O - A)))) / c;
            return (asin(s * (1 - x / c) * 2 / r / b) + asin(s * (1 - y / c) * 2 / r / a)) * r * r * 0.5 + s * ((y + x) / c - 1);
        }
    }
}

//多边形与圆面积交
double Polygon_intersect_Circle(Point ploy[],int n,Point o,double r)
{
    ploy[n] = ploy[0];
    double res = 0.0;
    for(int i = 0;i < n; i++) res += Triangel_cross_Circle(ploy[i],ploy[i + 1],o,r);
    return fabs(res);
}

//最小圆覆盖---随机增量
void min_cover_circle(Point p[], int n, Point &c, double &r) {
    random_shuffle(p, p + n);
    c = p[0];
    r = 0;
    for(int i = 1; i < n; i++) {
        if((p[i] - c).norm() > r + eps) { //第一个点
            c = p[i];
            r = 0;
            for(int j = 0; j < i; j++)
                if((p[j] - c).norm() > r + eps) { //第二个点
                    c = (p[i] + p[j]) * 0.5;
                    r = (p[j] - c).norm();
                    for(int k = 0; k < j; k++)
                        if((p[k] - c).norm() > r + eps) { //第三个点
                            //求外接圆圆心，三点必不共线
                            c = CircumCenter(p[i], p[j], p[k]);
                            r = (p[i] - c).norm();
                        }
                }
        }
    }
}


//判断多边形与线段交即判断多边形的每条边与线段交
//判断线段在多边形内即判断线段的两个端点在多边形内部
//应先判相交，再判内含关系……

//多边形面积
double Calarea(Point ploy[],int n)
{
    double res = 0.0;
    ploy[n] = ploy[0];
    for(int i = 0;i < n; i++) res += (ploy[i] ^ ploy[i + 1]);
    return fabs(res * 0.5);
}
//判断多边形是否是凸多边形,即对每条边判断其相邻两点是否在同侧即可

//判断点在凸多边形内，-1在多边形外，1在内，0在边上
int inConvexPoly(Point a,Point p[],int n)
{
    p[n] = p[0];
    for(int  i = 0;i < n; i++)
    {
        if(sgn((p[i] - a) ^ (p[i + 1] - a)) < 0) return -1;//若凸包为顺时针<改为>
        else if(isPointOnSegment(a,Line(p[i],p[i + 1]))) return 0;
    }
    return 1;
}
//判断点在任意多边形内：(需先特判点在多边形上)
作出要判断的点的水平线，对于多边形每条边作出判断：
如果两个端点一上一下或一下一个在水平线上，则视为有一个交点；否则视为无交点
求出所有交点，若在要判断点两侧的交点的个数都是奇数个，则点在多边形内部

//直线与简单多边形交,以下代码用于求直线在多边形内(包括边界)最长的连续部分
//整体思想为判断每一个线段是否在多边形内,用判断点是否在多边形内的方法实现
typedef pair<Point, int> Pt;
vector<Pt> g;
double solve(Line l, int n) {
    int i, a, b;
    g.clear();
    for(i = 0; i < n; i++) {
        if(!seg_line_inter(l, Line(p[i], p[i + 1]))) continue;
        pair<int, Point> e = l & Line(p[i], p[i + 1]);
        if(e.fi == -1) {
            g.push_back(Pt((p[i] + p[i + 1]) * 0.5, -1)); //边界与直线重合,加辅助点
            continue;
        }
        a = sgn((l.e - l.s) ^ (p[i] - l.s));
        b = sgn((l.e - l.s) ^ (p[i + 1] - l.s));
        if(a + b == 0) g.push_back(Pt(e.se, 2));  //一上一下
        else if(a + b == 1) g.push_back(Pt(e.se, 1));  //一下一个在水平线上
        else g.push_back(Pt(e.se, 0));  //无贡献点
    }
    int m = g.size();
    if(m == 0) return 0;
    sort(g.begin(), g.end());
    double res = 0, pre = 0;
    for(i = a = 0; i + 1 < m; i++) {
        if(g[i].se > 0) a++;  //左边的有效点个数
        if(g[i].fi == g[i + 1].fi) continue;  //重点,跳过
        if(g[i].se == -1 || g[i + 1].se == -1) pre += (g[i].fi - g[i + 1].fi).norm(); //这条线段是边界且在直线上,视为在内部
        else {
            if(a & 1) pre += (g[i].fi - g[i + 1].fi).norm(); //左边点为奇数个---在内部
            else {
                res = max(res, pre);  //在外部,更新答案
                pre = 0;
            }
        }
    }
    res = max(res, pre);
    return res;
}


//平面最近点对---分治
bool cmp1(const Point &a,const Point &b)
{
    if(a.x != b.x) return a.x < b.x;
    else return a.y < b.y;
}

bool cmp2(const Point &a,const Point &b)
{
    return a.y < b.y;
}

double solve(int l,int r)
{
    double d = 1e15;
    int i,j;
    if(l + 3 >= r)
    {
        for(i = l;i < r; i++)
        {
            for(j = i + 1;j <= r; j++) d = min(d,dist(f[i],f[j]));
        }
        return d;
    }
    int mid = (l + r) >> 1;
    int k = 0;
    d = min(solve(l,mid),solve(mid + 1,r));
    for(i = l;i <= r; i++)
    {
        if(fabs(f[i].x - f[mid].x) <= d) g[k++] = f[i];
    }
    sort(g,g + k,cmp2);
    for(i = 0;i < k; i++)
    {
        for(j = i + 1;j < k; j++)
        {
            if(g[j].y - g[i].y > d) break;
            d = min(d,dist(g[i],g[j]));
        }
    }
    return d;
}

int main(){
    int n,i;
    while(~scanf("%d",&n) && n)
    {
        for(i = 0;i < n; i++) scanf("%lf%lf",&f[i].x,&f[i].y);
        sort(f,f + n,cmp1);
        printf("%.2f\n",solve(0,n - 1));
    }
    return 0;
}






//旋转卡壳--两个多边形--应该可适用于单个多边形，要求多边形为凸
//最短距离用点到线段距离
//最远距离用两线段的端点距离
double rot_solve(Point a[],Point b[],int n,int m)
{
    int fa,fb,i;
    Point u;
    //寻找y轴最远点对
    for(fa = i = 0;i < n; i++)
    {
        if(a[i].y < a[fa].y) fa = i;
    }
    for(fb = i = 0;i < m; i++)
    {
        if(b[i].y > b[fb].y) fb = i;
    }
    a[n] = a[0];
    b[m] = b[0];
    double ans = MAX;
    for(i = 0;i < n; i++)//旋转卡壳，寻找对踵点
    {
        while(sgn(((a[fa + 1] - a[fa]) ^ (b[fb + 1] - a[fa]))- ((a[fa + 1] - a[fa]) ^ (b[fb] - a[fa]))) == 1) fb = (fb + 1) % m;
        u = Point_to_Seg(b[fb],Line(a[fa],a[fa + 1]));
        ans = min(ans,(b[fb] - u).norm());
        u = Point_to_Seg(b[fb + 1],Line(a[fa],a[fa + 1]));
        ans = min(ans,(b[fb + 1] - u).norm());
        fa = (fa + 1) % n;
    }
    return ans;
}


//求凸包，返回凸包点数
int convexhull(Point p[],int n,Point q[]){
    sort(p,p + n);
    int i,m = 0;
    for(i = 0;i < n; i++){
        while(m > 1 && sgn((q[m - 1] - q[m - 2]) ^ (p[i] - q[m - 2])) <= 0) m--;
        q[m++] = p[i];
    }
    int k = m;
    for(i = n - 2;i >= 0; i--){
        while(m > k && sgn((q[m - 1] - q[m - 2]) ^ (p[i] - q[m - 2])) <= 0) m--;
        q[m++] = p[i];
    }
    if(n > 1) m--;
    return m;
}




struct Line//两点式,定义方向向量又s指向e
{
    Point s,e;
    double ang;
    Line(){}
    Line(Point _s,Point _e)
    {
        s = _s;
        e = _e;
        ang = atan2(e.y - s.y,e.x - s.x);
    }
    //求两直线交点，-1重合，0相交，1平行
    pair<int,Point> operator &(Line b)
    {
        if(sgn((s - e) ^ (b.s - b.e)) == 0)
        {
            if(sgn((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(-1,s);
            else return make_pair(1,s);
        }
        double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));
        return make_pair(0,Point(s.x + (e.x - s.x) * t,s.y + (e.y - s.y) * t));
    }
    bool operator < (const Line &b) const
    {
        if(sgn(ang - b.ang) == 0) return ((s - b.s) ^ (s - e)) > 0;
        else return sgn(ang - b.ang) < 0;
    }
};
//判断点在直线左边
bool OnLeft(Line l,Point p)
{
    return sgn((l.e - l.s) ^ (p - l.s)) > 0;
}
// 半平面交 左半平面
// 存在重合的方向相反的直线可能仍会得到一个凸包，但是面积为0，需特判
Line que[maxn * 2];
int HalfplaneIntersection(Line l[],int n,Point p[])
{
    sort(l,l + n);//极角排序
    int i,tot = 1;
    for(i = 1;i < n; i++)
    {
        if(sgn(abs(l[i].ang - l[i - 1].ang)) != 0) l[tot++] = l[i];
    }
    int head = 0,tail = 1;
    que[0] = l[0];
    que[1] = l[1];
    for(i = 2;i < tot; i++)
    {
        while(head < tail && sgn(((que[tail] & que[tail - 1]).second - l[i].s) ^ (l[i].e - l[i].s)) > 0) --tail;
        while(head < tail && sgn(((que[head] & que[head + 1]).second - l[i].s) ^ (l[i].e - l[i].s)) > 0) ++head;
        que[++tail] = l[i];
    }
    while(head < tail && sgn(((que[tail] & que[tail - 1]).second - que[head].s) ^ (que[head].e - que[head].s)) > 0) --tail;
    while(head < tail && sgn(((que[head] & que[head + 1]).second - que[tail].s) ^ (que[tail].e - que[tail].s)) > 0) ++head;
    if(tail <= head + 1) return 0;//无解
    int m = 0;
    for(i = head;i < tail; i++)  p[m++] = (que[i] & que[i + 1]).second;
    if(head < tail - 1) p[m++] = (que[head] & que[tail]).second;
    return m;
}


//半平面ax+by+c>0转化为两点式
if(sgn(a) == 0)
        {
            if(sgn(b) == 0)
            {
                if(sgn(c) != 1) break;
                else continue;
            }
            L[k++] = Line(Point(0.0,-c / b),Point(sgn(b),-c / b));
        }
        else
        {
            if(sgn(b) == 0) L[k++] = Line(Point(-c / a,0.0),Point(-c / a,-sgn(a)));
            else L[k++] = Line(Point(0.0,-c / b),Point(sgn(b),-(c + a * sgn(b)) / b));
        }




//三角形重心
Point MassCenter(Point A,Point B,Point C)
{
    return (A + B + C) * (1.0 / 3.0);
}
//三角形内心
Point InnerCenter(Point A,Point B,Point C)
{
    double a = dist(B,C),b = dist(A,C),c = dist(A,B);
    return (A * a + B * b + C * c) * (1.0 / (a + b + c));
}
//三角形外心
Point CircumCenter(Point A,Point B,Point C)
{
    Point t1 = B - A,t2 = C - A,t3((t1 * t1) * 0.5,(t2 * t2) * 0.5);
    swap(t1.y,t2.x);
    return A + Point(t3 ^ t2,t1 ^ t3) * (1.0 / (t1 ^ t2));
}
//三角形垂心
Point OrthoCenter(Point A,Point B,Point C)
{
    return MassCenter(A,B,C) * 3.0 - CircumCenter(A,B,C) * 2.0;
}

//判断点P在三角形ABC内部，若sa,sb,sc中一个为0，另外两个相同，则在三角形边界上
bool PointInTriangle(Point A,Point B,Point C,Point P) {
    int sa = sgn((B - A) ^ (P - A));
    int sb = sgn((C - B) ^ (P - B));
    int sc = sgn((A - C) ^ (P - C));
    if(sa == sb && sa == sc) return true;
    else return false;
}




































struct Point3 {
    double x,y,z;
    Point3(double _x = 0.0,double _y = 0.0,double _z = 0.0): x(_x),y(_y),z(_z) {}
    Point3 operator +(const Point3 &b) const {
        return Point3(x + b.x,y + b.y,z + b.z);
    }
    Point3 operator -(const Point3 &b) const {
        return Point3(x - b.x,y - b.y,z - b.z);
    }
    double operator *(const Point3 &b) const { //点乘
        return (x * b.x + y * b.y + z * b.z);
    }
    Point3 operator ^(const Point3 &b) const { //叉乘
        return Point3(y * b.z - z * b.y,z * b.x - x * b.z,x * b.y - y * b.x);
    }
    Point3 operator *(const double &k) const {
        return Point3(x * k,y * k,z * k);
    }
    double norm() { //求模
        return sqrt(x * x + y * y + z * z);
    }
};

struct Line3 {
    Point3 s,e;
    Line3() {}
    Line3(Point3 _s,Point3 _e): s(_s),e(_e) {}
};

struct Plane {
    Point3 sa,sb,sc,e;//e是法向量
    Plane() {}
    Plane(Point3 _sa,Point3 _sb,Point3 _sc): sa(_sa),sb(_sb),sc(_sc) {
        e = (sa - sb) ^ (sb - sc);
    }
};
//两点距离
double dis_point(Point3 p1,Point3 p2) {
    return (p1 - p2).norm();
}
//判断三点共线，同判断点在直线上
bool dots_inline(Point3 p1,Point3 p2,Point3 p3) {
    return sgn(((p1 - p2) ^ (p2 - p3)).norm()) == 0;
}
//判断点在平面上,同判断4点共面
bool dots_oneplane(Plane PL,Point3 p) {
    return sgn(PL.e * (p - PL.sa)) == 0;
}
//判断点在线段上
bool dot_online(Line3 L,Point3 p) {
    return sgn(((p - L.s) ^ (p - L.e)).norm()) == 1 && sgn((L.s.x - p.x) * (L.e.x - p.x)) < 1
           && sgn((L.s.y - p.y) * (L.e.y - p.y)) < 1 && sgn((L.s.z - p.z) * (L.e.z - p.z)) < 1;
}

//判断点在空间三角形上,包括边界,(利用面积相等法判定)
bool dot_in_Triangle(Point3 p,Plane PL) {
    return sgn(((PL.sa - PL.sb) ^ (PL.sa - PL.sc)).norm() - ((p - PL.sa) ^ (p - PL.sb)).norm()
               - ((p - PL.sb) ^ (p - PL.sc)).norm() - ((p - PL.sc) ^ (p - PL.sa)).norm()) == 0;
}

//判断两点与线段位置关系，必须点线共面，不然无意义
//1 同侧; -1 异侧; 0 有点在线段所属直线上
int Point_Position_Seg(Point3 a,Point3 b,Line3 l) {
    return sgn(((l.s - l.e) ^ (a - l.e)) * ((l.s - l.e) ^ (b - l.e)));
}

//判断两点与平面位置关系
//1 同侧; -1 异侧; 0 有点在平面上
int Point_Position_Plane(Point3 a,Point3 b,Plane PL) {
    return sgn((PL.e * (a - PL.sa)) * (PL.e * (b - PL.sa)));
}

//判断两直线平行
bool Parallel_Line(Line3 l1,Line3 l2) {
    return sgn(((l1.s - l1.e) ^ (l2.s - l2.e)).norm()) == 0;
}

//判断两平面平行
bool Parallel_Plane(Plane PL1,Plane PL2) {
    return sgn((PL1.e ^ PL2.e).norm()) == 0;
}

//判断直线与平面平行
bool Parallel_L_P(Line3 l,Plane PL) {
    return sgn((l.s - l.e) * PL.e) == 0;
}

//判断两直线垂直
bool Vertical_Line(Line3 l1,Line3 l2) {
    return sgn((l1.s - l1.e) * (l2.s - l2.e)) == 0;
}

//判断两平面垂直
bool Vertical_Plane(Plane PL1,Plane PL2) {
    return sgn(PL1.e * PL2.e)== 0;
}

//判断直线与平面垂直
bool Vertical_L_P(Line3 l,Plane PL) {
    return sgn(((l.s - l.e) ^ PL.e).norm()) == 0;
}

//判断两线段相交
bool Interset_Seg(Line3 l1,Line3 l2) {
    if(!dots_oneplane(Plane(l1.s,l1.e,l2.s),l2.e)) return false;
    if(!dots_inline(l1.s,l1.e,l2.s) || !dots_inline(l1.s,l1.e,l2.e))
        return (Point_Position_Seg(l1.s,l1.e,l2) <= 0 && Point_Position_Seg(l2.s,l2.e,l1) <= 0);
    else return dot_online(l2,l1.s) || dot_online(l2,l1.e) || dot_online(l1,l2.s) || dot_online(l1,l2.e);
}

//判断线段与空间三角形相交
bool Interset_Triangle(Line3 l,Plane PL) {
    return Point_Position_Plane(l.s,l.e,PL) <= 0 && Point_Position_Plane(PL.sa,PL.sb,Plane(l.s,l.e,PL.sc)) <= 0
    && Point_Position_Plane(PL.sb,PL.sc,Plane(l.s,l.e,PL.sa)) <= 0 && Point_Position_Plane(PL.sc,PL.sa,Plane(l.s,l.e,PL.sb)) <= 0;
}

//求两直线交点,需先判断直线是否共面和平行
//求线段交点需先判断线段是否共面和平行和相交
Point3 Interset_L_L(Line3 l1,Line3 l2) {
    Point3 ret = l1.s;
    double t = ((l1.s.x - l2.s.x) * (l2.s.y - l2.e.y) - (l1.s.y - l2.s.y) * (l2.s.x - l2.e.x)) /
    ((l1.s.x - l1.e.x) * (l2.s.y - l2.e.y) - (l1.s.y - l1.e.y) * (l2.s.x - l2.e.x));
    ret = ret + (l1.e - l1.s) * t;
    return ret;
}

//求直线与平面交点，需先判断直线与平面是否平行，且平面的三点不能三点共线
//可求线段与空间三角形交点
Point3 Interset_L_P(Line3 l,Plane PL) {
    Point3 ret = PL.e;
    double t = (ret.x * (PL.sa.x - l.s.x) + ret.y * (PL.sa.y - l.s.y) + ret.z * (PL.sa.z - l.s.z)) /
    (ret.x * (l.e.x - l.s.x) + ret.y * (l.e.y - l.s.y) + ret.z * (l.e.z - l.s.z));
    ret = l.s + (l.e - l.s) * t;
    return ret;
}

//求两平面交线,需先判断两平面是否平行，且每个平面的三点都不共线
Line3 Interset_P_P(Plane P1,Plane P2) {
    Line3 ret;
    ret.s = Parallel_L_P(Line3(P1.sa,P1.sb),P2) ? Interset_L_P(Line3(P1.sb,P1.sc),P2) : Interset_L_P(Line3(P1.sa,P1.sb),P2);
    ret.e = Parallel_L_P(Line3(P1.sc,P1.sa),P2) ? Interset_L_P(Line3(P1.sb,P1.sc),P2) : Interset_L_P(Line3(P1.sc,P1.sa),P2);
    return ret;
}

//点到直线距离
double ptoline(Point3 p,Line3 l) {
    return ((p - l.s) ^ (l.e - l.s)).norm() / dis_point(l.s,l.e);
}

//点到平面距离
double ptoplane(Point3 p,Plane PL) {
    return fabs((PL.e * (p - PL.sa)) / PL.e.norm());
}

//直线到直线距离,需先判断两直线平行
double linetoline(Line3 l1,Line3 l2) {
    Point3 ret = (l1.s - l1.e) ^ (l2.s - l2.e);
    return fabs((l1.s - l2.s) * ret / ret.norm());
}